Introduction to GUI Programming in Python (TkInter)
# start 6/4

After completing this course you will know:

what GUI is and where it came from;
how to construct a GUI using basic blocks and conventions;
how event-driven programming works;
some popular and commonly used GUI environments and toolkits;
what tkinter is and how to build a GUI with its help;
how to use widgets, windows, and events, and how to create basic applications based on tkinter's application life cycle.

What is GUI?
GUI is an acronym. Moreover, it’s a three-letter acronym, a representative of a well-known class of acronyms which plays a very important role in the IT industry. Okay, that’s enough jokes about TLA’s for one course, all the more that GUI is present nearly everywhere. Look around you – you’ll see a couple of different devices equipped with screens: phone, tablet, computer, TV set, fridge, oven, even washing machine or heating controller – all these things have a screen, most of them colored and many (more and more every year) use it to display a GUI and to communicate with the user. They communicate bidirectionally.
GUI stands for Graphical User Interface. In this three-word acronym, the User seems to be the most obvious part. The word Interface needs some more reflection, but in fact, it is clear too – it’s a tool used by the user to command a device and to receive its responses.
But what does it mean that the interface is graphical?
We have to do a little time traveling to understand that. Don’t worry, it won’t take long. We’re going to travel not more than fifty years back. Are you ready? Okay, let’s go!

Terminals. For a very long time (about 30 years or even longer) displays weren’t treated as a part of computers. A computer (sometimes called a mainframe) was a very big box (much, much bigger than the biggest refrigerator you ever had in your home) with thousands of colored lights, blinking all the time, and hundreds of switches (also colored).
“Okay,” you may say, “nice image, but how could we control such a computer?” To control the computer, you needed to have a specialized and completely separate device called a terminal. The terminal needed to be wired to a computer (don’t forget that the Internet had not been invented yet) and was rarely placed in the same room. It could be placed in a different building, a different city or even on a different continent.

But the most intriguing part of the story was that the terminal: was monochrome (it could display either grey, amber, or green dots on a black or nearly black background);
wasn’t able to display anything but letters, digits, and a few other characters.

The latter limitation is the most important as it dictated the way software was built for a very long time, almost an era in the history of IT technology.
Think about it. Try to imagine what it was like to work with a computer without not being able to see a picture, not saying a word about movies or animations.
No photographs, no selfies, no avatars, no animated banners and finally, no colors. How do you like it? Take a look at the two classical terminals which exerted the greatest influence on the construction of such equipment and became worldwide industry standards. The first of them is the IBM 3270, and the second is the Digital Equipment Corporation’s VT100.

Now it’s time for the second part of our time travel adventure. Are you ready? The latter limitation is the most important as it dictated the way software was built for a very long time, almost an era in the history of IT technology. Think about it. Try to imagine what it was like to work with a computer without not being able to see a picture, not saying a word about movies or animations.
No photographs, no selfies, no avatars, no animated banners and finally, no colors. How do you like it? Take a look at the two classical terminals which exerted the greatest influence on the construction of such equipment and became worldwide industry standards. The first of them is the IBM 3270, and the second is the Digital Equipment Corporation’s VT100.

Now it’s time for the second part of our time travel adventure. Are you ready?

There are more disadvantages than just a lack of colors and a low resolution. Terminals had no pointing devices. No mice, no trackballs, no touch screens. They had keyboards (very different from contemporary keyboards installed inside laptops) and nothing more. Some of the terminals (very expensive and very rare models) could be equipped with a light pen. Don't be misled by this term – the pen's role wasn't to paint or draw anything. It was used to point to different screen areas and acted in a way very similar to a mouse. But believe us – you don't want to replace your mouse with this. Moreover, you don't want to replace your finger with the pen – it was heavy and the cable connected to it was usually thick and stiff. It's not surprising that the light pen didn't conquer the market. The most important aspect of the case is a question: how do we organize computer–user interaction with such limited options? The answer is exactly the same as the terminals of the time – in a strictly textual way.

Fun fact: Even though they look ancient, 3270 apps are still powering parts of the financial world, airlines, insurance companies, and government systems — often behind the scenes of modern web UIs.

It was just text – usually elegantly formatted, sometimes colorized (but still only text). The most commonly used terminals were able to display 80 columns and 25 lines. so there was not much space to utilize. The user's answer was given by pressing a set of allowed keys. Simple? Simple. From our present-day developer's perspective, too simple. From a user's point of view, difficult and inconvenient. This is why both developers and users wanted something new – something more flexible, more intuitive, and just nicer. Much nicer. The GUI was the answer, which is still widely used today. Let's go back to the present time.

Visual programming. Creating applications able to utilize GUI features is sometimes called visual programming. The term stresses the fact that an application's look is as important as its functionality, but it's not just a matter of what you see on the screen, but also what you can do to change its state, and how you force the application to submit to your will. The GUI created completely new possibilities unknown to users in previous eras: clicks and taps replaced keystrokes. We're going to show you that such programming demands a completely different approach, and a completely different understanding of application activities. Let's summarize some important aspects of visual programming. A working GUI application externalizes its existence by creating a window (or windows) visible on the screen. In some environments (e.g., on mobile devices) the window can occupy the whole screen, so not more than one application can be visible on screen at once.

The application's window is usually equipped with certain decorations: a title bar, a frame, buttons, icons, etc. As you probably know, the style in which the decorations are visualized and placed within the window may be treated as an operating system's birthmark. We're sure that you can distinguish different MS Windows versions just by looking at the colors and shapes visible on the screen. Some operating environments completely disable a user's effect on the way in which the OS decorates application windows. Others don't – the user can define their own style and colors of virtually all the GUI elements.
Some operating systems devote the whole screen to one application, so the decorations are extremely minimalistic or completely absent. Fortunately, it has very little effect on the developer's work.

Widgets. The user interacts with the GUI by using gestures: a mouse's movements, clicks targeting selected GUI elements, or by dragging other elements. Touch screens may offer something more: tapping (single or double or even more complex), swiping, and pinching. The GUI elements designed to receive such gestures are called controls or widgets. Note that the whole GUI idea was inspired by electrical control panels – devices full of switches, gauges, and colored warning lights. You'll find some traces of these inspirations in widget names. Don't be surprised. One of the widgets living inside a particular window owns the focus. The widget (which is also called the focused widget) is the default recipient of some or all of the user's actions. Of course, the focus may change its owner, which is usually done by pressing the Tab key.
For example, pressing the space bar may activate different activities depending on which of the window's widgets is currently focused. Now let's take a look at a very simple window.

Let's try to identify all visible window components. This is a very important distinction, as the window hides some of its secrets from the user. We can even say that each window comprises very complicated machinery driving all the window's behaviors. But we're not interested in that yet. First of all, the window has a title bar. It's one of the typical window decorations.

Inside the title bar there is (or can be) a set of control buttons. Our sample window contains only one: the closing button. Note that the location of these buttons is OS-dependent. Inside the title bar (as the name suggests) there is a window title. Of course, some of the windows may also be untitled. The window's interior is equipped with a set of widgets responsible for implementing the window's functionalities. Some of them are active (they can receive a user's clicks or, in other words, they are clickable) while others aren't. One of these non-clickables is an icon – a small picture that usually helps the user to quickly identify the issue.

Another non-clickable member of the window's team is a label – a piece of text inside a window which literally explains the window's purpose. As our sample window performs a very specific task (it asks a question and forces the user to reply), it needs two buttons assigned to the user's possible answers. The first of them is titled Yes and – look carefully! – it's currently focused! (the button has a dotted line around the yes/no box). 

Can you guess how we know that? Yes, it's shown by the thin dotted line drawn around the button. If you press the space bar now, it will be taken as an affirmative answer. The second of the buttons is not focused yet. What can we do to move the focus to the button? Yes, we can press the Tab key.

Note: the underlined letters within the buttons' title show the shortcuts. Pressing these keys has the same effect as clicking one of the buttons. And what does all this mean?

This means something very important to us. You may not want to believe us at the moment, but the traditional programming paradigm in which the programmer is responsible for responding to literally all the user's actions is completely useless in visual programming. Why? Because the number of all possible user moves is so substantial that continuous checking of the window's state changes, along with controlling all widget behavior, making the coding extremely heavy, and the code becomes badly bloated. In a slightly more suggestive way, you could also say that widgets aren't introverts. They are not in the habit of concealing their emotions, and like very much to influence other widgets (e.g., moving the focus always engages two widgets: the one that loses the focus and the one that gains it). This means that the programmer is obliged not only to control each of the widgets separately, but also their pair, triple, and so on.

Let's try to imagine it.

Look at the pseudo-code below:

while True:
    wait_for_user_action()
    if user_pressed_button_yes():
    :
    elif user_pressed_button_no():
    :
    elif user_move_mouse_coursor_over_button_yes():
    :
    elif user_move_mouse_coursor_over_button_no():
    :
    elif user_pressed_Tab_key():
        if isfocused(button_yes):
        :
        elif isfocused(button_no):
       :
    :
    :

Note: The pseudo-code is deprived of all details. Moreover, it's not complete. It covers less than about 10 % of all possible events, and should be heavily developed to behave in a reasonable way.
Believe us: you don't want to write a code like this one. Fortunately, you don't need to. Visual programming demands a completely different philosophy, or (expressing this thought in a more fashionable way) it needs a different paradigm. This paradigm exists, and is widely applied to create GUI applications.

It's called event-driven programming.

Classical vs. event-driven paradigm. What is EDP like? Or rather, what is EDP unlike? First of all, detecting, registering and classifying all of a user's actions is beyond the programmer's control – there is a dedicated component called the event controller which takes care of this. It's automatic and completely opaque. You don't need to do anything (or almost anything) to make the machinery run, but you are obliged to do something else.

You have to inform the event controller what you want to perform when a particular event (e.g., a mouse click). This is done by writing specialized functions called event handlers. You write these handlers only for the events you want to serve – all other events will activate default behaviors (e.g., focus moving and window closing). Of course, just implementing an event handler is not enough – you also have to make the event controller aware of it. Let's imagine that we have a function named DoSomething() which... does something. We want the function to be invoked when a user clicks a button called DO IT!.

In the classical paradigm we would have to:

discover the click and check if it happened over our button;
redraw the button to reflect the click (e.g., to show that it is actually pressed)
invoke the function.
In the event-driven paradigm our duties look completely different:

the event controller detects the clicks on its own;
it identifies the target of the click on its own;
it invokes the desired function on its own;
all these actions take place behind the scenes! Really!
Sounds good? Oh, yes, it does!

Events. Have you noticed? We silently introduced a new word into our discussion. It’s the event. What it is? Or rather, what could it be? There are lots of events which an event manager is committed to recognizing, discovering, and serving. Here are some of them:

pressing the mouse button;
releasing the mouse button (actually, an ordinary mouse click consists of these two subsequent events)
moving the mouse cursor;
dragging something under the mouse cursor;
pressing and releasing a key;
tapping a screen;
tracking the passage of time;
monitoring a widget’s state change;
and many, many more...

-----------------------------------------------------
|                     Event                         |
-----------------------------------------------------
                          |
                          v
-----------------------------------------------------
|                    Trigger                        |
-----------------------------------------------------
                          |
                          v
-----------------------------------------------------
|                 Event Handler                     |
-----------------------------------------------------
                          |
                          v
-----------------------------------------------------
|                   Event Loop                      |
-----------------------------------------------------
                          |
                          v
(loops back to Event)

TkInter. Unfortunately, each operating system delivers its own set of services designed to operate with its native GUI. Moreover, some of them (e.g., Linux) may define more than one standard for visual programming (two of the most widespread in the U*x world are named GTK and Qt). This means that if we want to build portable GUI applications (i.e., apps able to work under different operating environments that always look the same) we need something more – we need an adapter. A set of uniform facilities enables us, the programmers, to write one code and not worry about portability. Such an adapter is called a widget toolkit, a GUI toolkit, or a UX library. One of these toolkits, which is very attractive to us, is Tk.

Here are some of its features:
it’s free and open (we don’t need to pay for anything)
it has been developed since 1991 (which means it’s stable and mature)
it defines and serves more than thirty different universal widgets (which is enough even for quite complex applications)
its implementation is available for many programming languages (of course, for Python too)

The module that brings Tk to the Python world is named TkInter, which is short for Tk Interface. It’s free and open, too. You may have some trouble believing that you’ve been using TkInter for a long time, actually since your very first encounter with programming in Python. Yes, it’s true – IDLE, the very first Python IDE, is written using TkInter. We think this is the best recommendation – don’t you?

Importing TkInter. As you already know, from Python's point of view TkInter is a package named tkinter. The package contains a bunch of functions, constants, classes, objects, and modules used to build GUI applications. The GUI application itself consists of four essential elements:

importing the needed tkinter components;
creating an application’s main window;
adding a set of necessary widgets to the window;
launching the event controller.

That’s all. Really. Looks too good to be true? Let us show how it works. We’ll do it step-by-step. Ready? The simplest (and at the same time the less controllable) way of importing tkinter facilities is to import the package as a whole:

import tkinter

Note: it won’t allow you to access some modules built-in within the package and you will still have to import them separately. As you already now, such an import will force you to use the qualified names of tkinter’s components. If you don’t like to write long package names each time you make use of their contents, you can perform an import which renames the package (precisely: which creates an alias of its original name) at the time of import. tk looks shorter than tkinter, doesn’t it?

import tkinter as tk

Okay, we know there’s no accounting for taste, but it’s definitely worth accounting for code readability. The choice is entirely up to you. If you like to have full control over all your source code, you can make the import process extremely itemized by importing each of the facilities separately – just like this:

from tkinter import Button

If you're an enthusiast of living life on the edge, you can simplify your import (but not the rest of your work) by using the star as a component name:

from tkinter import *

It's handy when you write it, but it can bring some cumbersome troubles when names from the package's namespace cross with some of your private names. Don't think we're going to discourage you from using this form. It's only a warning. Or rather a piece of friendly advice. Now we're ready to create our first application. The application will be completely mute, deaf to the same extent as it is mute, and thus completely indifferent to any input. Don't worry, we'll breathe some life into it soon – it's only a very first step.

Look at the code in the editor. The main application window (which is often the only window being used by the application) is created by the tkinter method named Tk(). In its most commonly used form, it needs no arguments. The object returned by the method is complete, but at the same time, completely invisible. Moreover, it won't be visible until the event controller starts. To start the controller, you have to invoke the main window's method, named mainloop(). The name is significant because – as you can see – there is nothing more you can do in your code. Entering the controller's main loop deprives you of the possibility of direct control over the code's execution. Now you're fully at the mercy of the controller. Exiting the main loop is equivalent to finishing the application, as without the controller's companion there is nothing more you can do.

Let's run the code now.

import tkinter

skylight = tkinter.Tk()
skylight.mainloop()

Did you get the same window as ours? There are some issues with the window, and the most important is how to close it while also causing the application to quit. Currently, there is no other way than to make use of some of the OS's default behaviors, e.g., clicking the closing button (ours is red – and yours?) or using a dedicated keyboard shortcut like MS Windows®' Alt-F4. A preferable way of coping with that is to equip the window with a dedicated button, but now we're going to make a little cosmetic change. We don't like the window's title. We'll change it now. How? Each window (including the main one) has a method named – of course – title(). The method can be invoked more than once in any moment of the window's life. We'll activate it before the window is shown, just like the way we do it in the editor window.

Can you see it? The title has changed now!

Now it's the turn of the button. A button visible on the screen is, in fact, a reflection of an object of the Button class. To bring a button to life, you have to:

create a Button class object (it'll be done by the class's constructor)
place the button inside the main window (it'll be done by one of the window's methods)
Note the distinction: it can be said that the button creates itself, but to make it visible, you need the window's (not the button's!) method.

Take a look at the code in the editor window.
import tkinter

skylight = tkinter.Tk()
skylight.title("Skylight")
button = tkinter.Button(skylight, text="Bye!")
button.place(x=10, y=10)
skylight.mainloop()

To create a Button class object, we make use of its constructor. Its first argument (which is a reference to the target window) is obligatory. All others are optional. The one named text sets the initial button's title (note: the title can be changed at any time). The object saved inside the button variable is now created, but still invisible. Moreover, the main window doesn't know where to put it within its interior. Let's fix that. The act of placing the widget somewhere inside the window is done with a method named place(). As you can see, we use the method in a way in which the button's two coordinates are given: x and y. There are three important remarks that must be written here:

the widget's coordinates refer defaultly to the pixel occupied by the upper-left corner;
the widget's size is defaultly determined by the constructor in order to fit the widget's content (the title's length and height in this case)
the widget's location is measured in pixels, but there is one important issue which distinguishes the screen coordinates from the ones used by the geometry; look: this is what the Cartesian two-dimensional coordinates system looks like:

Axis 1.png

while the screen coordinates look as follows:

Axis 2.png ### top  left of screen is 0,0.

This means that a pixel described as (x=10,y=10) is located near the top-left window corner. Be aware of this! Now we're fully prepared to run the code.

Hi, Button! Nice to see you!

02.10.png

Can we click you? Of course we can. Does it change anything? No, it doesn't. Of course, the view of the button changes, simulating a real button's behaviors, but no other reactions can be seen. We don't like this. And this is the moment when we should hire a new member onto our team – an event handler.

import tkinter

skylight = tkinter.Tk()
skylight.minsize(400, 200) # use this with just title and prevent title wrapped
skylight.title("Skylight")
button = tkinter.Button(skylight, text="Bye!")
button.place(x=10, y=10)
skylight.iconbitmap('C:\Temp\Win.ico') #<<< replace default window icon
skylight.mainloop()

Event handler. An event handler is a piece of code responsible for responding to all clicks addressed to our button. The event handler we need has a simple assignment – we want it to just terminate our application. This crucial operation is done with a main window method called – don't be afraid – destroy(). It's a parameterless method, as destroying needs (in contrast to creation) no arguments at all.
How do we write the event handler? It's a function. Just a simple function. The handler used by the button has to be a parameterless function of any name. Don't forget that the function will be invoked, not by us, but only by the controller.
Furthermore, invoking your own handler is strictly prohibited, as it can completely confuse the event controller. We don't want the controller to be confused. It may end badly. Therefore, the simplest handler may look like this:

def Click():
    skylight.destroy()

Note: a function designed to be invoked by someone/something else (not us!) is often called a callback. We'll use the names handler and callback interchangeably. Okay, we have a handler, but how do we couple it with the rest of the window's machinery?
Look carefully at the Button's constructor invocation - we've provided the code in the editor. A new argument has appeared there. Its name is command, and it's set with the name of a callback that will be invoked when the button is clicked. Note: there are no parentheses, as we don't want to invoke the callback here – we need its name to be passed to the Button object.
Now we can run the code and check if our button is functional. We hope it is. Two remarks should be made here:

binding the callback with the widget by using the command constructor's parameter is not the only way offered by tkinter for this purpose; moreover, callbacks can be replaced during program execution – we'll tell you more about that soon;
the one and same callback can be bound with more than one widget – it's a very useful solution in some cases.

import tkinter
import time
import winsound

skylight = tkinter.Tk()
skylight.minsize(400, 200)
skylight.iconbitmap('C:\Temp\Win.ico')

def Click():
    #skylight.bell()
    winsound.Beep(1000, 500)  # 1000 Hz for 0.5 seconds
    time.sleep(0.15) # delayed reponse before close app
    skylight.destroy();
    
skylight.title("Skylight")
button = tkinter.Button(skylight, text="Bye!", command=Click)
button.place(x=10, y=10)
skylight.mainloop()

Of course, closing the window without asking the user if they are really sure that this is exactly what they want to do isn't a good way to build up a relationship with them. We definitely want to ask the user before we permanently remove their window from sight. Fortunately, tkinter is very helpful with this issue. There is a module named messagebox (the name speaks for itself) which is your great companion in this and similar matters. messagebox is able to create dialog boxes intended to ask questions, display messages, and to receive a user's reply.

The dialog box is an example of a modal window – a window which grabs the whole of the application's focus. It means that all other application widgets become deaf as long as the modal window is present. We've provided the amended code in the editor window.

Let's dive into our new code.

we've had to add a second import directive – as messagebox is a module located inside the tkinter package, we need to use the from variant of the import;
the essence of our modification is hidden inside the callback:
we invoke the askquestion() function by passing two arguments to it: the first will be used as a dialog window title, the second will be displayed inside the window to make the user aware of the incoming issue;
the askquestion() function returns a string which is equal to yes if the user has clicked the confirming button (note: the text on the button depends of the OS international settings, and will be set to the word yes or its local analog)
As you can see, the mechanism is easy and handy. Let's run the code and check its results. We hope that you see something like this:

Of course, our code is very disappointing. For example, the window can be closed instantly, without any question, when the user clicks the closing button. This is not very elegant; you'll probably agree with that. We ask you for forgiveness – this is only an example, obviously too simple to be utilized in regular conditions, but it gives us a good starting point from which to continue the journey into more complex tkinter facilities.

Stay tuned!

Settling widgets. A familiarity with the Button widget allows us to show you some ways of putting the widgets (not only the buttons) inside windows. There are more of them than just place(), which you learned about in the previous section. To be precise, there are three different methods. These methods are implemented by geometry managers. Place is the most detailed one. It forces you to precisely declare a widget's location, pixel by pixel. It won't, however, protect you from some common mistakes causing the widgets to overlap each other or to place some of them, partially or fully, outside the window.

If you don't want to deploy the widgets manually and worry about possible conflicts and failures, you may entrust the whole problem to tkinter. It'll try to guess your intentions and to find the best location for each widget. Unfortunately, its assumptions may not live up to your expectations, and the final result can be really disappointing. This method of settling widgets is implemented by the pack geometry manager. The grid geometry manager is in the middle, in between the other two geometry managers. It gives you a chance to express your general wishes and tries to deploy the widgets according to them. Note the word general – they aren't as precise as the ones used by place, but are far more detailed than those utilized by pack. There is one very important aspect of the issue that must be mentioned here: these managers cannot be mixed. Only one of them can be used in one application, unless you want to turn your window into a big mess. We're talking seriously about it. Don't take it as a joke.

The place geometry manager demands the usage of the place() method. Note: the method is invoked from within the widget's object, not the window, as the widget is always aware of the window it belongs to (it gets the information from the constructor's very first argument). The most usable place() method parameters are as follows (all of them are passed as keyword arguments):

height=h – the widget's desired height measured in pixels; if the parameter is omitted, the widget's height will be determined automatically;
width=w – the widget's desired width measured in pixels; if the parameter is omitted, the widget's width will be determined automatically;
x=x – the widget's top-left pixel's horizontal coordinate measured relative to the home window's top-left corner;
y=y – the widget's top-left pixel's vertical coordinate measured relative to the home window's top-left corner.
Let's see them all in action.

import tkinter as tk

window = tk.Tk()
button_1 = tk.Button(window, text="Button #1")
button_2 = tk.Button(window, text="Button #2")
button_3 = tk.Button(window, text="Button #3")
button_1.place(x=10, y=10)
button_2.place(x=20, y=40)
button_3.place(x=30, y=70)
window.mainloop()

The snippet we've prepared for you shows how the place() method works. Look at the code in the editor. It places three buttons in a cascade-like order. Try to guess what these buttons will look like inside the window. Yes, this is what we expected, isn't it? Now let's play with width and height for a moment.

Look, we've added some arguments to the previous snippet. Two buttons (b1 and b2) should look different now – can we be sure of it? Yes, we can!

import tkinter as tk

window = tk.Tk()
button_1 = tk.Button(window, text="Button #1")
button_2 = tk.Button(window, text="Button #2")
button_3 = tk.Button(window, text="Button #3")
button_1.place(x=10, y=10, width=150)
button_2.place(x=20, y=40)
button_3.place(x=30, y=70, height=50)
window.mainloop()

As you can see, using place() gives you full control over the window's image. There is only one important but — full control means full responsibility. Sometimes it's better to share the responsibility among two parts – e.g., you and the grid() geometry controller. grid() sees the window's area as a... grid. This means that the whole of the window's interior is divided into a number of columns of equal width and a number of rows of equal height. The grid itself is not visible – the distribution is modeled inside the manager and you are only able to know its effects i.e., the widget's final arrangement. You're not obliged to declare the number of rows and columns in advance – grid() finds the proper numbers for you. Let's try it.

The most commonly used grid() method parameters are gathered below (as, previously, all of them are passed as keyword arguments):

column=c – deploys the widget in the column number c; note: the columns' numbers start from zero, and if you omit this argument, the manager will assume 0 (the left-most column)
row=r – deploys the widget in the row number r; if you omit this argument, the manager will assume the first free row starting from the top;
columnspan=cs – determines how many neighboring columns the widget occupies; the parameter defaults to 1 (the widget won't cross a single grid's cell)
rowspan=rs – works as columnspan but refers to rows.
Let's see them all in action. Analyze the snippet in the editor and determine the resulting number of columns and rows. That's essential if you want to imagine the resulting window's appearance.

import tkinter as tk

window = tk.Tk()
button_1 = tk.Button(window, text="Button #1")
button_2 = tk.Button(window, text="Button #2")
button_3 = tk.Button(window, text="Button #3")
button_1.grid(row=0, column=0)
button_2.grid(row=1, column=1)
button_3.grid(row=2, column=2)
window.mainloop()

Are you ready to solve the puzzle? Did you imagine the window that way? We're sure you did. Look. The window is divided into nine cells: three rows and three columns. The buttons are settled on the grid's diagonal. Now we’re going to affect the buttons’ relation to the cells’ boundaries.

Can you see what we changed in the code? Yes, we modified the third grid() invocation a bit. We wanted to deploy the button inside the cell located in the third (actually, the lowest) row and the first (the left-most) column, but we also did something else – we wanted the widget to span across two horizontally neighboring cells. We admit that this puzzle is somewhat harder than the previous ones. Don't rush through this – think it over carefully.

Here's the solution.

import tkinter as tk

window = tk.Tk()
button_1 = tk.Button(window, text="Button #1")
button_2 = tk.Button(window, text="Button #2")
button_3 = tk.Button(window, text="Button #3")
button_1.grid(row=0, column=0)
button_2.grid(row=1, column=1)
button_3.grid(row=2, column=0, columnspan=2)
window.mainloop()

Note: the manager noticed that the total number of columns is actually two, not three as in the previous code. This is why the window looks different. The third, fully automatic geometry manager is named pack() as it packs subsequent widgets into the window's interior. This means that the order in which the widgets are packed matters – in contrast to grid() and place(). Let's take a look at it.

The default pack's operation tends to deploy all subsequent widgets in one column, one below the other. You can change this behavior to a limited extent by using the following parameters:

side=s – forces the manager to pack the widgets in a specified direction, where s can be specified as:
TOP – the widget is packed toward the window's top (it's manager's default behavior)
BOTTOM – the widget is packed toward the window's bottom;
LEFT – toward the window's left boundary;
RIGHT – toward the window's right boundary;
fill=f – suggests to the manager how to expand the widget if you want it to occupy more space than the default, while f should be specified as:
NONE – do not expand the widget (default behavior)
X – expand it in the horizontal direction;
Y – expand it in the vertical direction;
BOTH – expand it in both directions;
We want to warn you that the results produced by pack() can be extremely surprising, and you should spend some time on your own experimenting with all its vices.

We suggest you use it only as a temporary solution to help you get a working application quickly, but if you want your application to look nice and to be legible and clear (of course, you would want that!) you'd better forget about pack() and use either grid() (in simpler cases) or place(). Let pack() show us what it can do for us. Look at the code in the editor.

import tkinter as tk

window = tk.Tk()
button_1 = tk.Button(window, text="Button #1")
button_2 = tk.Button(window, text="Button #2")
button_3 = tk.Button(window, text="Button #3")
button_1.pack()
button_2.pack()
button_3.pack()
window.mainloop()

As you can see, using pack() simplifies the code – you don't need to specify any coordinates – but that doesn't mean this will simplify the developer's life. You may expect that pack() will know how to handle your widgets, but sometimes it's work results are like a lottery. Let's look at the window we get. The window looks different. Very different. For example, the window fits its size to the area occupied by the widgets. The buttons are located one after the other, from top to bottom.

Let's play a little game with pack's arguments. We've ordered pack() to push the button_1 button to the right window's boundary. Can you predict the window's appearance? We admit that it may be difficult.

import tkinter as tk

window = tk.Tk()
button_1 = tk.Button(window, text="Button #1")
button_2 = tk.Button(window, text="Button #2")
button_3 = tk.Button(window, text="Button #3")
button_1.pack(side=tk.RIGHT)
button_2.pack()
button_3.pack()
window.mainloop()

Is this what you expected? No? Are you surprised? You have the right to be. Pack is the least intuitive geometry manager for sure, and you really need to spend some time testing its whims. We have one more experiment left to carry out.

Note: we want the button_1 button to be filled (expanded) in the vertical direction: This puzzle is a bit easier than the previous one. Think for a moment. Yes, you're right – this is the expected answer.

import tkinter as tk

window = tk.Tk()
button_1 = tk.Button(window, text="Button #1")
button_2 = tk.Button(window, text="Button #2")
button_3 = tk.Button(window, text="Button #3")
button_1.pack(side=tk.RIGHT, fill=tk.Y)
button_2.pack()
button_3.pack()
window.mainloop()

We think that there is one intriguing question that can be asked here and now: do these buttons have to be gray? It's boring. Very boring. We're going to clear up this issue soon.

Adding colors. Nearly everything you put inside your windows may be colored. Most widgets have dedicated properties to handle their colors and we will tell you about them while discussing the widgets themselves. Currently, the most important thing is getting to know how the colors are described in tkinter, in other words, what means can you use to order the button to be red or blue.
There are at least three methods designed to meet your needs. We will tell you about them on the example of Button but don't forget that these ways are universal and can be used virtually everywhere.
Let's check if tkinter understands English – look at the code in the editor, our test is there. Note the two new arguments we use in the constructor invocation: bg (what is a short form of “background-color”) and fg (“foreground-color”). We went along the line of least resistance here – we've just made use of regular English names of colors and packed them inside strings.

Does it work? Let's check.Yes, it definitely does: We encourage to you make some clicks on the button – it will unveil its little secret. Can you see? The colors of the lowered (pressed) button are gray still. Why?
Because fb and bg refer to raised buttons only. There two additional parameters describing the second set of colors named activeforeground and activebackground respectively used by the event controller when the button is pressed. Do you want to check how they work? Do it boldly! We can summarize the test's result saying that any of commonly used English color name can be used with tkinter. Don't bother if you want some of your widgets to be simply white, black, green, gray or even grey. It's easy and handy although not very precise.

import tkinter as tk

window = tk.Tk()
button = tk.Button(window, text="Button #1",
                   bg="MediumPurple",
                   fg="LightSalmon",
                   activeforeground="LavenderBlush",
                   activebackground="HotPink")
button.pack()
window.mainloop()

Tkinter can do something more for you. Tkinter recognizes over 750 predefined color names – all of them can be found here. Feel free to use them – we've showed our try in the editor.
This is what we get: Yes, it definitely does: The third method you can use is based on the fact that each color can be obtained by mixing (adding) three primary colors: red (R), green (G) and blue (B). The phenomenon is utilized by the so-called RGB color model which is one of the additive color models and it's widely used in many application, e.g. in color displays of different kinds.

One of the RGB model implementations allows you to set the saturation of every of primary colors in the range <0..255> what gives 256 different saturation levels, from color's absence (saturation 0) to full color's presence (saturation 255). Do you think it's not too much? Maybe, but don't forget that you mix three different colors (so-called color components) so the full spectrum consists of 256*256*256 = 16,777,216 colors. An average human can distinguish about 7 million colors, consequently, the model should work well and it really does.

Let's take a closer look at this.

When all the components are set to zero (absence of the colors), we get black as a result.
When all the components are set to 255 (full presence of the colors), we get white as a result.
When one of the components is set to 255 while others are set to 0, we get one of the primary colors – red, green or blue.

Setting non-zero values for more than one component produces intermediate colors, e.g. red and blue set to 255 with green set to 0 gives the violet. It seems clear, doesn't it? OK, but how to specify all these (more than 16 million) mixes in a comprehensive way? It's is done by a trick used extensively in web pages – as a string starting with a hash (#) followed by 6 hexadecimal digits. Each pair of the digits forms the value from range 0x00..0xFF (0..255) what determines the specific component level.

This is how it works:

All three pairs (RR, GG and GG) are two-digit hexadecimal number so:

#000000 is black
#FFFFFF is white
#FF0000 is red
#00FF00 is green
#0000FF is blue
#00FFFF is turquoise
#FF00FF is violet
...
Please, forgive us that we made that list so short. To tell the truth, we have no idea how to name each of these 16 million colors – do you? Note: when all the components are set to the same value, equal neither to zero nor to 0xFF (e.g. #0F0F0F0), you will get 254 shades of gray.

Look at the code in the editor. We want to show you you a little test showing how the RGB works: Do the colors look the same as in the previous code? They should look the same as we used RGB equivalents of the previously used tkinter color names. Now try to find RGB codes for all your favorite colors. There are so many choices – don't feel lost!

import tkinter as tk

window = tk.Tk()
button = tk.Button(window, text="Button #1",
                   bg="#9370DB",
                   fg="#FFA07A",
                   activeforeground="#FFF0F5",
                   activebackground="#FF69B4")
button.pack()
window.mainloop()

Building a GUI application from scratch. Now we're going to build a very simple and rather useless GUI application. Does that sound weird? Maybe, but the application, when ready, will make you more accustomed to some tkinter habits and conventions. Our fabulous goal will look like the vision presented below:

Are you ready? Let's start. As everyone knows, Rome wasn't built in a day, and our application isn't an exception. We'll start with something absolutely obvious – we'll construct a window and launch an event controller – look at the code in the editor to see how to do it. Our window looks like this one for now: There's nothing surprising yet. Let's add something to this dull gray area.

# the pack() method is used with the Tkinter library, which is a standard GUI (Graphical User Interface) toolkit. The pack() method is one of the geometry managers in Tkinter, and it is used to organize widgets in blocks before placing them in the parent widget, which can be the main window or a frame.

Our new friend is called Label – a non-clickable widget able to present short textual information, passed to the widget's constructor using a text argument. The text can later be changed at any moment of the widget's life. As you can see, we're using the pack() geometry manager to compose the window. Let's welcome Label into our window:

Note: pack() resizes the window to a size large enough to fit all the packed widgets. This is its default behavior. Don't worry, the window will grow soon.

Our next companion will be Frame. A Frame is another non-clickable component used to group widgets and to separate them (visually) from other window components. Our Frame plays a less important role – it just occupies a rectangle and fills it with its own color. We expect nothing more for now. Let's check it out. This is how the Frame manifests its presence:

Make our window great again.

Now we invite a Button to join our team. Our Button will be completely mute, as we haven’t bound anything to its command property. You can change that if you want. This is what our window looks like now:

import tkinter as tk

window = tk.Tk()

label = tk.Label(window, text="Little label:")
label.pack()

frame = tk.Frame(window, height=30, width=100, bg="#000099")
frame.pack()

button = tk.Button(window, text="Button")
button.pack(fill=tk.X)

window.mainloop()

Our next component is completely invisible. You won't find it in the window area. It's the switch variable. Can't you see it? It's set to hold an object of the IntVar class. This object is designed to store integer values. "Okay," you may say, "can't we use a regular variable instead?" No, we can't. Objects of the IntVar class are used by tkinter to organize internal communication between different widgets. A regular variable can't play such a role. If you want such an object to store an integer value, you can't use the assignment operator. The class offers a dedicated method for that purpose, and the method is named set().
Note: we've used the method to store a value of 1 inside the object. As the window's view hasn't changed, we can go directly to the next step.

switch = tk.IntVar()
switch.set(1)
window.mainloop()

The next step adds a brand new widget to our window – it’s a Checkbutton. It’s a small square which can be filled with a tick mark, or which can be empty. The Checkbutton is primarily used to represent two-state selections. In other words, it can be in one of two possible states:

the ON state when the Checkbutton is checked/ticked (which can be equated with an affirmative answer to some question)
the OFF state when the Checkbutton is cleared (you can think of it as a kind of negative answer)
Take a look at the Checkbutton constructor – there’s something completely new. Can you see it?

Yes, it’s a variable argument. Note – it’s set to the previously created switch object. The assignment creates a bidirectional link between the object and the widget. How does it work?
If you check or uncheck the Checkbutton, the switch object will immediately change its state – it will keep 0 if the widget is unchecked, and 1 otherwise.
If you change the state of the switch object, the Checkbutton will immediately reflect the change – it means that you don’t need to access the Checkbutton itself to check/uncheck it, as you can modify the switch value instead. Look, the switch is initially set to 1. this means that the Checkbutton will be checked when it appears on the screen. Let's check it.

import tkinter as tk

win = tk.Tk()

label = tk.Label(win, text="Little label:")
label.pack()

frame = tk.Frame(win, height=30, width=100, bg="#000099")
frame.pack()

button = tk.Button(win, text="Button")
button.pack(fill=tk.X)

switch = tk.IntVar()
switch.set(1)

checkbutton = tk.Checkbutton(win, text="Check Button", variable=switch)
checkbutton.pack()

win.mainloop()

Our next component is completely invisible. You won't find it in the window area. It's the switch variable. Can't you see it? It's set to hold an object of the IntVar class. This object is designed to store integer values. "Okay," you may say, "can't we use a regular variable instead?"
No, we can't. Objects of the IntVar class are used by tkinter to organize internal communication between different widgets. A regular variable can't play such a role. If you want such an object to store an integer value, you can't use the assignment operator. The class offers a dedicated method for that purpose, and the method is named set().
Note: we've used the method to store a value of 1 inside the object. As the window's view hasn't changed, we can go directly to the next step.

The next step adds a brand new widget to our window – it’s a Checkbutton. It’s a small square which can be filled with a tick mark, or which can be empty. The Checkbutton is primarily used to represent two-state selections. In other words, it can be in one of two possible states:

the ON state when the Checkbutton is checked/ticked (which can be equated with an affirmative answer to some question)
the OFF state when the Checkbutton is cleared (you can think of it as a kind of negative answer)
Take a look at the Checkbutton constructor – there’s something completely new. Can you see it?

Yes, it’s a variable argument. Note – it’s set to the previously created switch object. The assignment creates a bidirectional link between the object and the widget. How does it work?

If you check or uncheck the Checkbutton, the switch object will immediately change its state – it will keep 0 if the widget is unchecked, and 1 otherwise.
If you change the state of the switch object, the Checkbutton will immediately reflect the change – it means that you don’t need to access the Checkbutton itself to check/uncheck it, as you can modify the switch value instead.
Look, the switch is initially set to 1. this means that the Checkbutton will be checked when it appears on the screen.

Let's check it.

import tkinter as tk

win = tk.Tk()

label = tk.Label(win, text="Little label:")
label.pack()

frame = tk.Frame(win, height=30, width=100, bg="#000099")
frame.pack()

button = tk.Button(win, text="Button")
button.pack(fill=tk.X)

switch = tk.IntVar()
switch.set(1)

checkbutton = tk.Checkbutton(win, text="Check Button", variable=switch)
checkbutton.pack()

win.mainloop()

This is what our window looks like now: 05.11.png Okay, it definitely looks as expected, but how can we be sure that the switch object changes its state according to our clicks addressed to the Checkbutton?
We’ll show you soon. Stay tuned. Now we add a very important, and internally an extremely complicated, widget, named Entry. Look at the code in the editor. Entry is designed to let the user enter simple, one-line data, like single numbers, names, addresses, etc.
We’ve added one to our window. It creates an input field 30 characters wide. You can play with it if you want, but it’s completely inoperative as far. We only want to show you what it looks like. Isn’t our window lovely?
05.13.png. Okay, let’s provide some serious work to our switch object.

We’ve added two widgets at once – look! These are the Radiobuttons, small circles filled with a dot, or not. The most important difference between Check- and Radiobuttons lies in the fact that Checkbuttons are solitary (they work individually) while Radiobuttons always work in groups and – note it! – only one of the widgets inside the group can be checked. Clicking an unchecked member of the group will cause the currently checked Radiobutton to change its state.
How do we achieve such an effect? The switch object will help us with it. Our two Radiobutton constructors use two additional arguments. What roles do they play? The variable argument binds a switch object to both of the widgets, and this is the clue – the fact that both Radiobuttons are bound to the same object creates the group. Don’t forget that!
The value argument distinguishes the Radiobuttons inside the group, and thus each of the Radiobuttons has to use a different value (we’ve used 0 and 1). The communication through the switch object should work as follows:

selecting one of the Radiobuttons affects the switch object, which changes its value to one of the possible values specified in the Radiobuttons’ constructor; note: the mechanism works in the same way if there are more Radiobuttons in the group;
simultaneously, changing the switch object’s state affects the Radiobutton group. As the switch is initially set to 1, we expect the second Radiobutton (named Salad) to be selected when the application starts.

Do you want to check it? Go ahead!

>import tkinter as tk

window = tk.Tk()

label = tk.Label(window, text="Little label:")
label.pack()

frame = tk.Frame(window, height=30, width=100, bg="#000099")
frame.pack()

button = tk.Button(window, text ="Button")
button.pack(fill=tk.X)

switch = tk.IntVar()
switch.set(1)

checkbutton = tk.Checkbutton(window, text="Check Button", variable=switch)
checkbutton.pack()

entry = tk.Entry(window, width=30)
entry.pack()

radiobutton_1 = tk.Radiobutton(window, text="Steak", variable=switch, value=0)
radiobutton_1.pack()
radiobutton_2 = tk.Radiobutton(window, text="Salad", variable=switch, value=1)
radiobutton_2.pack()

window.mainloop()

We hope we’ve lived up to your expectations: There is something more you should note. As the Checkbutton and Radiobutton groups are coupled together by the switch object, their changes are synchronized.
Check this carefully!

If you check/uncheck the Checkbutton, the Radiobutton group will follow the change immediately and vice versa, while switching the active Radiobutton inside the group will automatically check/uncheck the Checkbutton.
Now you’re ready to dive deeper into tkinter. Let’s dive together.

Event handling. As you already know, events are the fuel which propel the application’s movements. All events come to the event manager, which is responsible for dispatching them to all the application components. This also means that some of the events may launch some of your callbacks, which makes you responsible for preparing the proper reactions to the user’s actions.
Now it’s time to show you some details of the events’ lives and anatomy. We’ll also show you how the events are able to influence a widget’s state, and how you control the event manager’s behavior. For now, however, we want you to focus your attention on a very helpful method we’ll use to arrange communication between you and your application.

Of course, you can use the regular print() function to show messages and present a debug trace. The output will appear in the standard Python console, without affecting the application window. It’s okay if used in the early stages of development, but it’s very inelegant if you want the application to behave in a mature way.

The function we’ll use for our experiments is named showinfo(), it comes from the messagebox module, and it needs two arguments which are strings: messagebox.showinfo(title, info)

the first string will be used by the function to title the message box which will appear on the screen; you can use an empty string, and the box will be untitled then;
the second string is a message to display inside the box; the string can be of any length (but remember, the screen isn’t elastic and won’t stretch if you’re going to display a whole encyclopedia volume); note: you can use the \n digraph to visually break the info into separate lines. We’ll ask the showinfo() function to show us its possibilities.

In the editor we've provided a very simple code demonstrating how showinfo() works: Note the \n embedded inside the info string. And this is what the final message box looks like:

import tkinter
from tkinter import messagebox

def clicked():
    messagebox.showinfo("info", "some\ninfo")
    window.bell()

window = tkinter.Tk()
button_1 = tkinter.Button(window, text="Show info", command=clicked)
button_1.pack()
button_2 = tkinter.Button(window, text="Quit", command=window.destroy)
button_2.pack()
window.mainloop()

If your widget is a clickable one, you can connect a callback to it using its command property, while the property can be initially set by the constructor invocation. We’ve already practiced this, so the snippet in the editor won’t be a surprise to you. Note – there are three widgets in all, but only one of them (the Button) is clickable by nature. Such a widget’s constructor is equipped with the command parameter, which is used to bind a callback. The window along with its message box looks like this:

import tkinter as tk
from tkinter import messagebox

def click():
    tk.messagebox.showinfo("Click!","I love clicks!")

window = tk.Tk()
label = tk.Label(window, text="Label")
label.pack()

button = tk.Button(window, text="Button", command=click)
button.pack(fill=tk.X)

frame = tk.Frame(window, height=30, width=100, bg="#55BF40")
frame.pack();

window.mainloop()

#Another example
import tkinter as tk

def on_click(event):
    print("Button clicked!")

root = tk.Tk()
button = tk.Button(root, text="Click Me")
button.pack()

# Bind the left mouse button click event to the button
button.bind("<Button-1>", on_click)

root.mainloop()

#The widget.bind(event, callback) method is commonly used in graphical user interface (GUI) programming, particularly with the Tkinter library in Python. This method is used to bind an event to a widget, so that when the event occurs, a specified callback function is executed. Here's a breakdown of the components:

widget: This is the GUI element (such as a button, label, or entry) to which you want to bind the event.
event: This is a string that specifies the type of event you want to bind to the widget. Events can include things like mouse clicks, key presses, or other user interactions. For example, "<Button-1>" represents a left mouse button click, and "<KeyPress-A>" represents pressing the "A" key on the keyboard.
callback: This is the function that will be called when the specified event occurs. The callback function typically takes at least one argument, which is an event object containing information about the event.
#

Some of the widgets (especially those that are not clickable by nature) have neither a command property nor a constructor parameter of that name. Fortunately, you’re still able to bind a callback to any of the events it may receive (including clicks, of course) and this is done with a method named – it couldn’t be anything else – bind(): widget.bind(event, callback) The bind() method needs two arguments:
the event you want to launch your callback with; the callback itself. Looks clear, doesn’t it? Of course, there are two questions that should be answered immediately:

Q: What is an event from the event controller’s point of view?
A: It’s an object carrying some useful info about what actually happens when the event has been induced (by the user or by another factor).
Q: How are the events identified?
A: By unique names – each event has its own name and the name is just a unified string.

Useful events. We’ve gathered some of the most usable event names – don’t try to learn them by heart.

Event name	Event role
<Button-1>	Single left-click (if your mouse is configured for a right-handed user)
<Button-2>	Single middle-click
<Button-3>	Single right-click
<ButtonRelease-1>	Left mouse button release

Note: there are also events named <ButtonRelease-2> and <ButtonRelease-3>
<DoubleButton-1>	Double left-click

Note: there are also events named <DoubleButton-2> and <DoubleButton-3>

Note again: the <Button-1> event is a part of <DoubleButton-1> too; if you assign a callback to <Button-1>, it will be launched, too!

Event name	Event role
<Enter>	Mouse cursor appears over the widget
<Leave>	Mouse cursor leaves the widget area
<Focus-In>	The widget gains the focus
<Focus-Out>	The widget loses the focus
<Return>	The user presses the Enter/Return key
<Key>	The user presses any key

Event name	Event role
x	The user presses x key (x can be neither a space nor the < key)
<space>	The user presses the spacebar
<less>	The user presses the < key
<Cancel>	The user presses the key/keys used by the current OS to stop the program (e.g., Ctrl-C or Ctrl-Break)
<BackSpace>	The user presses the Backspace key
<Tab>	The user presses Tab key

Event name	Event role
<Shift_L>	The user presses one of the Shift keys
<Control_L>	The user presses one of the Control keys
<Alt_L>	The user presses one of the Alt keys
<Pause>	The user presses the Pause key
<Caps_Lock>	The user presses the Caps Lock key
<Esc>	The user presses the Escape keys

Event name	Event role
<Prior>	The Page Up key
<Next>	The Page Down key
<End>	The End key
<Home>	The Home key
<Left>

<Right>
<Up>
<Down>	Cursor (arrows) keys
<Num_Lock>
<Scroll_Lock>	The two Lock keys
<Shift-x>
<Alt-x>
<Control-x>
<KeyPress>

Don’t be afraid if some of the events look a bit suspicious. You’ll get used to them soon. Note:
a callback designed for usage with the command property/parameter is a parameterless function;
a callback intended to cooperate with the bind() method is a one-parameter function (the callback’s argument carries some info about the captured event)
fortunately, it doesn’t mean that you have to define two different callbacks for those two applications, and this is how we’ll cope with the above requirements:

def callback(ev=None):
    :
    :

the callback will work flawlessly in both of these contexts, and moreover, it’ll give you the chance to identify which one of the two possible styles of launch has just occurred.
We’re going to change our previous example a bit by making it sensitive to more than just one click. We've provided the newer version of our code in the editor. Pay attention to Line I and Line II in the above code. They show the way in which you can bind your callback to any of non-clickable widgets. The bind remains active to the end of the application’s work, but you can also manually unbind the event at any moment (and bind it again when you wish). We encourage you to play with the code – test the behavior of some of the other events. It’ll be fun... we think. We’ve said previously that an event is actually an object. Let’s shed some light on that.













