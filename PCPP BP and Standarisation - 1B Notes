PCPP1: Best Practices and Standardization (Python Enhancement Proposals)

In this course, you will learn about:

PEP 20 (The Zen of Python)
PEP 8 (Style Guide for Python Code)
PEP 257 (Docstring conventions)
how to avoid common errors and mistakes when writing code;
how to write elegant and effective code.

What is PEP? PEP may refer to several things:

football (soccer) fans will definitely associate it with the famous ex-footballer and football manager, Josep Guardiola, whose nickname is (guess what) Pep;
those who have medical jobs will surely think of post-exposure prophylaxis, which in turn has to do with taking preventive medical measures after contact with pathogens;
physicians will think of the proton-proton chain reaction;
some older (?) gamers will visualize the image of Pep, the dog, a funny character from a popular children’s Atari computer game of the early nineties;
while Python programmers will immediately point to an online document, which outlines the language standards and provides information about many changes and processes related to Python.
In this module, as you may expect, we’re going to focus on the last of the many PEPs.

In the jungle of PEPs. There are many PEPs, hundreds of them. See PEP 0 -- Index of Python Enhancement Proposals (PEPs) to find out for yourself that they’re no idle words.
https://peps.python.org/

It would be remarkable, but unfortunately quite a challenge, to cover them all in this course. For this reason, we’ve picked four of them that deserve a closer analysis, and should be considered must-reads. These are:

PEP 1 – PEP Purpose and Guidelines, which provides information about the purpose of PEPs, their types, and introduces general guidelines;
PEP 8 – Style Guide for Python Code, which gives conventions and presents best practices for Python coding;
PEP 20 – The Zen of Python, which presents a list of principles for Python’s design;
PEP 257 – Docstring Conventions, which provides guidelines for conventions and semantics associated with Python docstrings.
We encourage you to dive into PEPs on your own. We’re sure you‘ll become more and more curious about them as your programming experience and awareness grow.

PEP 1 – PEP Purpose and Guidelines. PEP is an acronym that stands for Python Enhancement Proposals, which, in fact, is a collection of guidelines, best practices, descriptions of (new) features and implementations, as well as processes, mechanisms and important information surrounding Python.
Simply speaking, if a new feature is planned to be added to Python, it will be detailed in a PEP along with the technical specifications and the rationale for its implementation.
That’s what, among other things, PEP is for.

There are three different types of PEPs:
Standards Track PEPs, which describe new language features and implementations;
Informational PEPs, which describe Python design issues, as well as provide guidelines and information to the Python community;
Process PEPs, which describe various processes that revolve around Python (e.g., propose changes, provide recommendations, specify certain procedures).

PEP 1 – PEP Purpose and Guidelines (cont.)
PEPs are primarily addressed to Python developers and members of the Python community. They are maintained as text files in a repository, and can be accessed online at https://www.python.org/dev/peps/.

But did you know that you can propose your own PEP, too? If you have a new (brilliant) idea for Python, you are more than welcome to become your PEP’s champion, i.e., the one who writes a PEP proposal, puts it up for discussion in subject-related forums, and tries to reach a community consensus over it.
PEP formats, templates, and the submission process (including reporting bugs and submitting updates) as well as the subsequent stages: review, resolution, and maintenance, are all described in detail within PEP 1 – PEP Purpose and Guidelines. Feel free to quickly browse through it – you never know when you’re going to need it!

Last but not least, PEP 1 defines:
Python’s Steering Council, i.e., a five-person committee and the final authorities who accept or reject PEPs;
Python’s Core Developers, i.e., the group of volunteers who manage Python, and;
Python’s BDFL, i.e., Guido van Rossum, the original creator of Python, who served as the project’s Benevolent Dictator For Life until 2018, when he resigned from the decision-making process.

PEP 20 – The Zen of Python. The Zen of Python is a collection of 19 aphorisms, which reflect the philosophy behind Python, its guiding principles, and design.
Tim Peters, a long time major contributor to the Python programming language and Python community, wrote this 19-line poem on the Python mailing list in 1999, and it became entry #20 in the Python Enhancement Proposals in 2004. It’s one of the Easter eggs (i.e., hidden, secret messages or features) included in the Python interpreter. Now let’s see the magic. Go to the editor window, type in import this, run the code, and voilà! Can you see what happens?

import this
#output

The Zen of Python, by Tim Peters   

Beautiful is better than ugly.     
Explicit is better than implicit.  
Simple is better than complex.     
Complex is better than complicated.
Flat is better than nested.        
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!

What you see is a collection of some general truths for Python design rules and decision making. Even though the "poem" seems to be imbued with contradictions and allusions, we assure you that the aphorisms are extremely practical and common sense, and you’re encouraged to accept them and implement in your code.
These, of course, should be looked upon holistically, rather than individually, but, still, let’s try to meditate on each of them.

Beautiful is better than ugly. Beauty is a rather subjective experience. But, as Immanuel Kant said, the very esthetic experience of beauty is a judgement of human truth. And even though the computer doesn’t care about beauty or esthetics, people do, and we must remember that a nicely-written program is not only more enjoyable to read, but also more readable. Python has certain style rules that programmers are recommended to follow. These are, among other things: a 79-character maximum line length, variable naming conventions, placing statements on separate lines, and many others.

Example: Write a program that calculates the hypotenuse of a right-angled triangle.

#bad
from math import sqrt
sidea = float(input("The length of the 'a' side:"))
sideb = float(input("The length of the 'b' side:"))
sidec = sqrt(a**2+b**2)
print("The length of the hypotenuse is", sidec )

#better
from math import sqrt

side_a = float(input("The length of the 'a' side: "))
side_b = float(input("The length of the 'b' side: "))
hypotenuse = sqrt(a**2 + b**2)

print("The length of the hypotenuse is", hypotenuse)

Explicit is better than implicit. The code you write should be explicit and readable.
Whenever you want to use an implicit feature of the language, ask yourself whether you really need it. Maybe there’s a better way to implement the functionality. If not, think about leaving a comment in code to explain what’s going on so that other programmers find it easier to understand your code.
In Python, it’s preferred to use not only the simplest way to express a programming idea, but also the most explicit, concrete, specific one.

Explicit is better than implicit. Therefore, it’s sometimes a good idea to add more verbosity to your code as it all counts towards readability. Giving self-explanatory variable and function names, or adding more explicitness to imports or function arguments may be good practice.

Example: Import apples and bananas from the fruit.py module.

#bad
from fruit import *

apples(2, 3.45)

#better
from fruit import apples, bananas

apples(quantity=2, price=3.45)

Simple is better than complex. Simplicity is the key to success.
A simpler solution is usually preferred over a complex one, and generally, the minimalistic approach wins. Remember: use appropriate tools adjusted to the specificity of your project. Using a plane to transport yourself to a nearby shop could be okay (assuming you’re slightly eccentric), but usually it’d be enough to walk or drive. Similarly, you wouldn’t normally walk the distance if you wanted to travel from the UK to the USA. Taking a plane would be a more sensible idea here. Consider not adopting an object-oriented approach when it’s not needed. Use fewer lines of code if that’s possible.

If you need to implement a more complex solution, divide problems into smaller, simpler parts.

#bad
import heapq

numbers = [-1, 12, -5, 0, 7, 21, 15, 1]
heapq.heapify(numbers)

sorted_numbers = []

while numbers:
    sorted_numbers.append(heapq.heappop(numbers))

print(sorted_numbers)

#better
numbers = [-1, 12, -5, 0, 7, 21, 15, 1]
numbers.sort()

print(numbers)

Complex is better than complicated. When simple solutions are not possible, be aware of the limitations carried by simplicity, and use complex solutions instead.
Distinguishing between complex as consisting of many elements and complicated, meaning difficult to understand, is yet another thing to consider when writing code.
In other words, there are times when a complex solution may be preferred over a simple one, especially in the case of the latter causing misunderstanding, doubt, or misinterpretation. You should avoid those. On the other hand, complex is always preferred to complicated. When your code gets big and too difficult to understand and grasp, divide it into well-separated parts, so that it’s easier to manage and handle.

Avoid misunderstanding, lack of clarity, and miscomprehension.

Example: Perform five additions of two numbers.

#bad
first_number = int(input("Enter the first number: "))
second_number = int(input("Enter the second number: "))
addition_result = first_number + second_number
print(first_number, "+", second_number, "=", addition_result)
first_number = int(input("Enter the first number: "))
second_number = int(input("Enter the second number: "))
addition_result = first_number + second_number
print(first_number, "+", second_number, "=", addition_result)
first_number = int(input("Enter the first number: "))
second_number = int(input("Enter the second number: "))
addition_result = first_number + second_number
print(first_number, "+", second_number, "=", addition_result)
first_number = int(input("Enter the first number: "))
second_number = int(input("Enter the second number: "))
addition_result = first_number + second_number
print(first_number, "+", second_number, "=", addition_result)
first_number = int(input("Enter the first number: "))
second_number = int(input("Enter the second number: "))
addition_result = first_number + second_number
print(first_number, "+", second_number, "=", addition_result)

#better
def addition(x, y):
    print(x, "+", y, "=", x+y)

for i in range(5):
    first_number = int(input("Enter the first number: "))
    second_number = int(input("Enter the second number: "))
    addition(first_number, second_number)

Flat is better than nested. Nesting code makes it more difficult to follow and understand. Nesting two or three levels deep may still be good, but anything beyond that becomes confusing and unreadable. Even though you can actually have any level of nested loops or if statements in Python, anything above three should be a clear signal that it’s maybe a good time to start refactoring your code. Flat code is more user-friendly, and becomes much easier to maintain. Remember this.

Example: Display a message whether or not x is within the range from 4 to 6.

#bad
x = float(input("Enter a number: "))

if x > 0:
    if x > 1:
        if x > 2:
            if x > 3:
                if x >= 4:
                    if x <= 6:
                        print("x is a number between 4 and 6.")
else:
    print("x is not a number between 4 and 6.")

#better
x = float(input("Enter a number: "))

if x >= 4 and x <=6:
    print("x is a number between 4 and 6.")
else:
    print("x is not a number between 4 and 6.")

Flat is better than nested. Nesting code makes it more difficult to follow and understand. Nesting two or three levels deep may still be good, but anything beyond that becomes confusing and unreadable. Even though you can actually have any level of nested loops or if statements in Python, anything above three should be a clear signal that it’s maybe a good time to start refactoring your code. Flat code is more user-friendly, and becomes much easier to maintain. Remember this.

Example: Display a message whether or not x is within the range from 4 to 6.

#bad
x = float(input("Enter a number: "))

if x > 0:
    if x > 1:
        if x > 2:
            if x > 3:
                if x >= 4:
                    if x <= 6:
                        print("x is a number between 4 and 6.")
else:
    print("x is not a number between 4 and 6.")

#better
x = float(input("Enter a number: "))

if x >= 4 and x <=6:
    print("x is a number between 4 and 6.")
else:
    print("x is not a number between 4 and 6.")

Sparse is better than dense. Don’t write too much code in one line, don’t fit too much information into a small amount of code, don’t write lines of code that are too long, use whitespaces responsibly – this all affects the readability and understanding of your program. The easiest and most common way to introduce sparsity to your code is to introduce nesting. That’s probably why this aphorism comes right after the one which tells us to prefer flat code over nested code. The key to readability is to strike a balance between the two: reduce nesting, then try to reduce density.

Example: Print the message “Hello, World!” if the value passed to the x variable equals 1.

#bad
x = 1
if x == 1 : print("Hello, World!")

#better
x = 1
if x == 1:
    print("Hello, World!")

Readability counts. Your code is not only read by computers, it’s also (or most of all) read by humans. In fact, it’s the essence of the Python philosophy, and the whole of Python design and culture actually revolves around the very statement that “code is read more often than it is written” (Guido Van Rossum).
All the previous aphorisms (and the subsequent ones) pave the way to readability, to a lesser or greater extent, as one of the most crucial factors that should be kept in mind while creating code. Whenever you feel tempted to give up on readability, the reason be it saving time by having to think up meaningful names, the effort taken to format your code, or any other reason – reject the temptation. Don’t underestimate the power of readability, especially when you have to return to your code after some time, or leave the code for others to develop in the future. Giving meaningful names to variables, functions, modules, and classes; properly styling blocks of code; using comments where necessary; keeping your code neat and elegant – these all contribute to how readable and user-friendly your code is.

Remember: the readability of your code reflects how responsible a programmer you are. It not only reflects well on the quality of the code, it reflects well on its author.

Example: Write a program that calculates a product’s gross price.

#bad
def f(i):
    l = i + (0.08 * i)
    return l

# better
# Calculates the gross price of products in Wonderland.
def calculate_gross_price(net_price):
    gross_price = net_price + (0.08 * net_price)
    return gross_price

Special cases aren't special enough to break the rules... Discipline, consistency, and compliance with standards and conventions are all important elements in professional and responsible code development. There should be no exceptions that allow us to break the principles governing best coding practices.
No special cases such as time pressure or complexity of a given problem should be an excuse for writing code that does not follow the guidelines.
It’s not only about readability, though it should be one of the first things you think about, but it’s also about sticking to the design and development-related decisions you’ve made, be it consistency which can ensure backward compatibility, keeping naming conventions unchanged, or anything else.

Example: Write a function that multiplies two numbers and a function that adds two numbers.

#bad
def multiply_two_numbers(first_number, second_number):
    return first_number * second_number

print(multiply_two_numbers(7, 9))

def addingTwoNumbers(firstNumber, secondNumber):
    return firstNumber + secondNumber

print(addingTwoNumbers(7, 9))

#better
def multiply_two_numbers(first_number, second_number):
    return first_number * second_number

print(multiply_two_numbers(7, 9))

def add_two_numbers(first_number, second_number):
    return first_number + second_number

print(add_two_numbers(7, 9))

...Although, practicality beats purity. Okay… what’s going on here? The previous aphorism encouraged us to never break the rules, while this one says there might be some exceptions to this. Why? Well, we must remember that the ultimate goal is to solve real problems and write code that performs some particular (expected) task. If your code is elegant, readable, and complies with all the important styling conventions, but does not function the way it should, then it doesn’t make much sense, does it?

If the possible benefits (e.g., better performance) are larger than the possible negative effects (e.g., affected maintainability), the real-world coding problems may find an excuse for making an exception to the rules. Practicality then becomes more important than purity.

If you need to write an 85-character long line of code because splitting it into two separate lines affects readability, do it. If you need to keep compatibility with previously written code and use CamelCase instead of snake_case, do it. Rules sometimes have to be broken, exceptions have to be made.

Errors should never pass silently..."...Unless explicitly silenced." Analyze a potentially dangerous situation below:

number = input("Enter a number: ")
multiply_number_by_two = number * 2

print("Your number multiplied by two is:", multiply_number_by_two)

Let’s assume that the programmer has forgotten to convert the value assigned to the number variable to int or float. The program will not crash. On the contrary, it will run without any problems and output a fine result. Although, far from expected. If the snippet constitutes just a tiny part of the whole code, the programmer might have difficulty finding the source of an error and debugging the program as no explicit error message is displayed in the console.
Let’s make some changes and improve the snippet a bit:

number = int(input("Enter a number: "))
multiply_number_by_two = number * 2

print("Your number multiplied by two is:", multiply_number_by_two)

What happens when the user enters 3.5 or two as the input? Well, Python will of course loudly inform you that there’s been something wrong: it will raise the ValueError exception. The Python language provides a very good mechanism for error handling, with a number of built-in exceptions, and a great toolset for creating user-defined exception handling systems. The Zen of Python gently reminds us that if a block of code is unable to perform its function and work in the way that is expected by the programmer, it should terminate the program and/or loudly announce that something has gone wrong (i.e., raise an exception) rather than continue running without interruption.

A program that crashes is easier to debug than a program that silences an error. Raising an exception draws your attention to the issue and provides important information about what happened and why. Errors which pass silently may infect the program and change its operation so that it becomes unpredictable, unexpected, and undesired.

One of the most difficult jobs a programmer needs to do is to think of all the possible contexts (or at least as many of them as possible) in which an exception may occur. Serving these exceptions and providing a remedy for expected (and well-handled) errors is an important challenge, but at the same time a crucial responsibility of a good, professional programmer.

Example: An explicitly silenced error (using the except keyword). However, the exception is too broadly handled:

try:
    print(1/0)
except Exception as e:
    pass

An improved version, handling a specific kind of an error:

try:
    print(1/0)
except ZeroDivisionError:
    print("Don't divide by zero!")

Well, naturally there may be situations where you don’t want to shout “Hey! There’s an error!” but rather handle it in a subtle way and not necessarily make a fuss about it. Analyze the code below in which we handle an exception by adding a default value:

try:
    number = int(input("Enter an integer number: "))
except:
    number = 0

In the face of ambiguity, refuse the temptation to guess. Guesses will surely work in many cases, but in many others they may bitterly disappoint you. This guideline conveys a twofold message: on the one hand, it tells you to have limited trust in the code you’re writing, while on the other hand, it implies that you should have limited trust in the code you’re reading. But what does that mean?

The first thing to remember is to always test your code before releasing it to production and deploying it to customers. Sounds obvious and reasonable? Well, yes, but many times programmers neglect or forget about this simple habit, be it because they trust their coding skills to the extent they, for example, reject any possibility of making typos, or because they work under great time pressure and feel they have no time for testing.

An important thing to keep in mind is: testing your code allows you to save time, not waste it. If you find a bug at an early stage, it will cost you less time and money to fix it. If you don’t test your code and it turns out there’s a bug at an advanced stage of development, corrections may be a pretty expensive and time-consuming enterprise.

Another thing is that you should avoid writing ambiguous code, which means you should leave no room for guessing. Give your variables self-commenting names, and leave comments where necessary. If you’re importing a module, make the import an explicit one. If a particular snippet is complex or complicated, explain its functioning. Never leave comments or use names that are wrong, confusing or misleading!

By the same token, if you suspect there’s something wrong in the code you’re reading, or feel there’s something unclear in it, do not guess its operation – test it!

Let’s analyze the following example:

fun(1, 2, 3)
fun(a=1, b=2, c=3)


The two function invocations may be the same, but not necessarily. It’s not possible to know without seeing the function definition. If the function definition is like the one below, the results could differ:

def fun(x=0, y=0, z=0, a=1, b=2, c=3):
    pass

Let’s take a look at one more example:

print("A" > "a")
print(1.0 == 1)
print("1" == 1)
print(True == "1")
print(True == 1)
print(True == 1.0)
print("1" + "1")
print(1 + 1)
print(1 + "1")

Do you know the result of the above snippet? Are you certain, or are you guessing? Would the above comparisons and expressions provide the same results across different programming languages? Well, not necessarily... If you’re working on a program that accepts data from the user, don’t rely on your guesses, because what you assume to be the most common may turn out to be the least common when faced with real-life data.

For example, if you’re writing an app that accepts text from the user, specify what encoding you expect from them, and accept only this particular encoding, handling all the cases the expected encoding is not providing. If you need to perform a conversion, use specialized, valid tools for that to avoid character garbling or program crashes. Always remember to look for the contexts in which your program might crash, and serve them. Don’t rely on your guesses or conviction that the user will strictly follow your instructions. Analyze the fragment of a simple interactive Python session we’ve provided below. Can you see what went wrong?

>>> integer_number = int(input("Enter an integer number: "))
Enter an integer number: 15.6
Traceback (most recent call last):
  File "<pyshell#4>", line 1, in <module>
    integer_number = int(input("Enter an integer number: "))
ValueError: invalid literal for int() with base 10: '15.6'

2.1.1.13 PEP 20 – The Zen of Python

There should be one – and preferably only one – obvious way to do it. “Although that way may not be obvious at first unless you're Dutch.”

There may be multiple ways of achieving the same goal. For example, if you want to take the user’s first name and last name, and display them on the screen, you can do it in one of the following ways:

first_name = input("Enter your first name: ")
last_name = input("Enter your last name: ")

print("Your name is:", first_name, last_name)
print("Your name is:" + " " + first_name + " " + last_name)
print("Your name is: {} {}".format(first_name, last_name))

Which one of them is the preferred one? It depends on what you want to achieve, how you want to format the outputted text, what past conventions were used, etc.

It seems there’s nothing wrong with having multiple ways to do a certain thing, as long as we’re ready for confrontation, and are able to agree on the best way to achieve a particular goal. 

The guideline also reminds us that it’s a good idea to follow the language use standards and conventions. For example, if you’ve been using snake_case to name your variables in your code so far, it may be a bad idea to start using CamelCase for the rest of your code within one and the same program. Well, unless you do this for a specific purpose, and the advantages of such an approach are bigger than the disadvantages.

Finally, the aphorism works as a gentle indication of yet another important piece of advice: where possible, it’s good to remember that each function, each class, each method – each entity – should have a single cohesive responsibility. Why? Because such an approach helps you gain more clarity and produce cleaner code, makes it easier and cheaper to maintain it, and less vulnerable to bugs.

When it comes to the second part of the aphorism, on the one hand it is meant to be a joke: the Dutch surely have a different way of thinking, different worldview, and different way of getting down to doing things (you certainly remember that Guido van Rossum is Dutch, too).

On the other hand, however, it indicates that working out how to obtain the best solution can be a long and challenging process: one obvious way to do something may not necessarily be obvious at first. Finding a relevant and preferred solution may require time, effort, and changing certain habits.

Python itself is a good example of this – it’s still evolving, its features and the ideas around it are changing, and Python programmers may still perceive relatively similar things differently.

What’s the best way to access values in a dictionary: using the get() method, or the syntax my_dict['key'], or some other way? What’s the best way to read a file: block by block, line by line? What’s the best way to print the user’s first and last names on the screen…?

Now is better than never. “Although never is often better than *right* now.”

You should not put off till tomorrow what you can do today. It’s a well-known proverb. Why? Well, because there’s never a good time for anything – there are always some “buts” and “ifs” which tell you to wait longer and delay things. Before you actually get down to doing these things – writing your code – you may have forgotten the ideas or information you need to do it well.

Python lets you quickly translate your ideas into working code. Whenever you experience the eureka effect or have your moment of inspiration, write down your thoughts and encode them in Python (or at least use some form of pseudocode) – even if your code is far from perfect. You can later refine, develop, or redesign it very easily.

Another thing to remember is that there is no such thing as a perfect thing. You can work hard to move closer to perfection, refine your code, refactor it several times, but it will never be perfect. No single thing can, and you must be aware of that. If you give in to temptation to complete a program and release it only when it’s perfect, it’s highly probable you will never do it.

Your program has the expected functioning? It passes all the tests? Maybe it’s ready for the world to see it?

On the other hand, the aphorism tells us not to forget about the proper balance. Just as perfect is the enemy of good, it often turns out that faster is the enemy of slower. There are cases when things should not be rushed.

Your function’s not working as expected and you cannot fix it today? Mark it as deprecated so that you don’t forget about it:

def deprecated_function():
    raise DeprecationWarning

Your project needs to go through the testing stage? Do you need to collect feedback from the users? The marketing campaign is not ready yet? Take the time to get everything right and release the product when it’s really ready, not when it looks ready.

If the implementation is hard to explain, it's a bad idea. “If the implementation is easy to explain, it may be a good idea.”
Everything and anything that can be explained in words can be translated into code, and eventually turned into a well-operating computer program.

If you can explain what you expect from a program, what you want it to do – such a program can be designed. If you find it difficult to explain its features and functionality, it may be a signal that maybe your idea should be thought over again and digested.

Simplicity and minimalism are the keys again (though such ones that don’t kill readability). Simple is better than complex, but complex is better than complicated – if you’ve already forgotten, here’s a subtle reminder. Keep things simple; the simpler, the better.

However, even though something’s easy to explain, it doesn’t mean it’s good. It’s just easier to judge whether it is or not. When you’re in doubt, have your implementation reviewed by your peers and see how much effort it takes them to grasp the idea and understand the whole concept. Another pair of eyes can cast new light on your project and help you see it in a new way.

Namespaces are one honking great idea – let's do more of those! Python provides a good, well-organized namespace mechanism to manage the availability of identifiers that you want to use and avoid conflicts with already existing names across different scopes.

What is a namespace? Generally speaking, it’s “a mapping from names to objects” (https://docs.python.org/3/tutorial/classes.html) implemented in Python in the form of a dictionary. What does it mean? Simply speaking, it means that whenever you define a variable, Python “remembers” two things: the variable’s identifier, and the value you pass to it.

How does it happen? Python implicitly adds them to an internal dictionary which resides within a particular scope, i.e., the region of a Python program where namespaces are accessible. If you want to access that variable, Python looks up its name in the dictionary and returns the value passed to it. If the variable doesn’t exist and, hence, isn’t found, then it raises the NameError exception.

Functions, classes, objects, modules, packages… they’re all namespaces. This fact results in the following: a more specific namespace cannot be altered by a less specific namespace, as they reside within two different scopes (e.g., a local variable inside a function doesn’t influence a global variable*). However, a more specific namespace has access to a less specific namespace (e.g., a global variable can be accessed from within a function).

*Using the global keyword before a global variable inside the function is a mechanism that allows you to alter that variable, even though it resides in a different scope (bad practice).

Use the namespaces to make your code clearer and more readable. For example, do this:

from instruments import guitars

guitars.fender(page)
guitars.ibanez(vai)

Instead of this:

from instruments.guitars import fender, ibanez

fender(page)
ibanez(vai)

Why? Because the first example will clearly show that fender and ibanez come from a different module, not from within the local scope.

Introduction to PEP 8. As mentioned earlier, PEP 8 is a document that provides coding conventions (code style guide) for Python code.

PEP 8 is considered one of the most important PEPs and a must-read for every professional Python programmer, as it helps to make the code more consistent, more readable, and more efficient.

Even though some programming projects may adopt their own style guidelines (in which case such project-specific guidelines may be favored over the conventions provided for by PEP 8, especially in the case of any conflicts, or backwards-compatibility issues), the PEP 8 best practices are still highly recommended reading, as they help you to better understand the philosophy behind Python and become a more aware and proficient programmer.

PEP 8 is still evolving as new, additional conventions are being identified and included in it, and at the same time some old conventions are being identified as obsolete and discouraged from being followed.

The Hobgoblin of Little Minds
”A foolish consistency is the hobgoblin of little minds.” This is a quote from Ralph Waldo Emerson’s essay “Self-Reliance” where Emerson urges readers to be consistent in their beliefs and practices. In our case, it means we must not forget about one simple but important observation: our code will be read much more often than it will be written.

On the one hand, consistency is a crucial factor that determines code readability. On the other hand, inconsistency with PEP 8 may at times be a better option. If the style guides are not applicable to your project, it may be better to ignore them and decide for yourself what is best. As PEP 8 says:

A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important. [...] However, know when to be inconsistent [...]. When in doubt, use your best judgement.

When should you ignore some specific PEP 8 guidelines (or at least consider doing so)?

If following them will mean that you break backwards compatibility.
If following them will have a negative effect on code readability.
If following them will cause inconsistency with the rest of the code. (However, this may be a good opportunity to rewrite the code and make it PEP 8 compliant.)
If there is no good reason for making the code PEP 8 compliant, or the code predates PEP 8.
PEP 8 is intended to improve code readability and “make it consistent across the wide spectrum of Python code.” Keeping your Python code compliant with PEP 8 is, therefore, a good idea, but you should never blindly adhere to these recommendations. You should always use your best judgement.

PEP 8 compliant checkers. There are many useful tools that can help you validate your code style and check it against PEP 8 style conventions. These tools can be installed and run locally, or accessed online. We want to show you just two of them, but we encourage you to explore further on your own:

pycodestyle (formerly called pep8, but the name was changed to avoid confusion) - Python style guide checker; it lets you check your Python code for conformance with the style conventions in PEP 8. You can install the tool with the following command in the terminal:

$ pip install pycodestyle

You can run it on a file or files to obtain information about non-conformance (and indicate errors in the source code and their frequency).

More information: https://github.com/PyCQA/pycodestyle
Documentation: https://pycodestyle.pycqa.org/en/latest/

You can also install autopep8 to automatically format your Python code to conform to the PEP 8 guidelines. To be able to use it, you need the pycodestyle installation on your machine in order to indicate those parts of the code which require formatting fixes.

More information: https://pypi.org/project/autopep8/

PEP 8 online is an online PEP 8 checker created by Valentin Bryukhanov which lets you paste your code or upload a file, and validate it against the PEP 8 style guidelines. The online tool is built using Flask, Twitter Bootstrap, and the PEP8 module (the very same module we’ve just described).

More information: http://pep8online.com/about >>> seems down. google found: https://www.codewof.co.nz/style/python3/

Recommendations for Code Layout
PEP 8 is supposed to make your coding experience better and your life a whole lot easier. As stated before, the way you write your code has a big impact on its readability. However, you should not forget it can determine its syntactic legality, too.

In this section, we’ll focus on style recommendations related to such things as:

indentation, using tabs and spaces;
line length, line breaks, and blank lines;
source file encoding and module imports.
Indentation
The indentation level, understood as the leading whitespace (i.e., spaces and tabs) at the beginning of each logical line, is used to group statements.

When writing code in Python, you should remember to follow these two simple rules:

Use four spaces per indentation level, and;
Use spaces rather than tabs.
However, you can use tabs when you wish to keep consistency with code that has already been indented with tabs (if it’s not possible or efficient to make it PEP 8 compliant).

Note: Mixing tabs and spaces for indentation is not allowed in Python 3. This will raise a TabError exception: “TabError: inconsistent use of tabs and spaces in indentation”.

Examples:

# Bad:
def my_fun_one(x, y):
    return x * y

def my_fun_two(a, b):
  return a + b

# Good:
def my_function(x, y):
    return x * y

Continuation lines. Continuation lines (i.e., logical lines of code that you want to split because they’re too long or because you want to improve readability) are allowed if using parentheses/brackets/braces:

# Bad:
my_list_one = [1, 2, 3,
    4, 5, 6
]

a = my_function_name(a, b, c,
    d, e, f)

# Good:
my_list_one = [
    1, 2, 3,
    4, 5, 6,
    ]

a = my_function_name(a, b, c,
                       d, e, f)

# Good:
my_list_two = [
    1, 2, 3,
    4, 5, 6,
]

def my_fun(
        a, b, c,
        d, e, f):
    return (a + b + c) * (d + e + f)


You can read more about indentation in the context of continuation lines at https://www.python.org/dev/peps/pep-0008/#indentation.

Maximum Line Length and Line Breaks
If possible, you should limit all lines to a maximum of 79 characters as this will help you avoid wrapping several lines of code. If line wrapping is inevitable, use Python’s implied line continuation from the previous page.

In the case of docstrings and comments, the line length should not exceed 72 characters. Max line length and line breaks

For convenience, if agreed by a team (or teams) working on a given project, according to PEP 8, it’s possible to increase the line length to 99 characters (this does not relate to docstrings/comments, whose line length should still remain limited to 72 characters).

Still, the Python Standard Library is conservative in this matter, and requires you to use no more than 79 characters per line (72 for comments/docstrings).

Line breaks and operators
Even though in Python you’re allowed to break code lines before or after binary operators (providing you do so consistently and that this convention has been used in your code before), it is recommended that you follow Donald Knuth’s style suggestions and break before binary operators as this results in a more readable, eye-friendly code.

Example:
# Recommended

total_fruits = (apples
                + pears
                + grapes
                - (black currants - red currants)
                - bananas
                + oranges)

Blank Lines. Blank lines, called vertical whitespaces, improve the readability of your code.

They allow the person reading your code to see the division of the code into sections, help them better understand the relation between the sections, and grasp the logic of given blocks of code more easily. In the same fashion, using too many blank lines in your code will make it look sparse and more difficult to follow, which is why you must always be careful not to overuse them.

PEP 8 recommends that you should use:

– two blank lines to surround top-level function and class definitions:

class ClassOne:
    pass

Class ClassTwo:
    pass

def my_top_level_function():
    return None
– a single blank line to surround method definitions inside a class:

class MyClass:
    def method_one(self):
        return None

    def method_two(self):
        return None


– blank lines in functions in order to indicate logical sections (sparingly). For example:

def calculate_average():
    how_many_numbers = int(input("How many numbers? "))
    
    if how_many_numbers > 0:
        sum_numbers = 0
        for i in range(0, how_many_numbers):
            number = float(input("Enter a number: "))
            sum_numbers += number

        average = 0
        average = sum_numbers / how_many_numbers

        return average
    else:
        return "Nothing happens."

Default encodings. It is recommended that you use Python’s default encodings (Python 3 -- UTF-8, Python 2 -- ASCII). Non-default encodings are discouraged and should only be used for test purposes or in situations where your comments or docstrings use a name (e.g., an author’s name) that contains a non-ASCII character.
PEP 8 states that “all identifiers in the Python standard library MUST use ASCII-only identifiers, and SHOULD use English words whenever feasible".

Note: See PEP 3131 (Supporting Non-ASCII Identifiers) for more information about the rationale as well as the pros and cons of using non-ASCII identifiers.

Imports. You should always put imports at the beginning of your script, between module comments/docstrings and module globals and constants, respecting the following order:

Standard library imports;
Related third-party imports;
Local application/library specific imports.
Make sure you insert a blank line to separate each of the above groups of imports.

PEP 8 recommends that your imports be on separate lines, rather than squeezed onto one line:

# Bad:
import sys, os

# Good:
import os
import sys

Still, it’s correct to make a one-line import using the from … import … syntax:

from subprocess import Popen, PIPE. If possible, use absolute imports (i.e., imports that use absolute paths separated by full stops). For example:

import animals.mammals.dogs.puppies

Such imports are preferred in Python, especially when your application is not overgrown or extremely complex.

You shouldn’t (and actually you cannot) use implicit relative imports, as these are no longer present in Python 3. You should also avoid using wildcard imports, for example:

from animals import *

as they inhibit code readability and may interfere with some of the names already present in the namespace.

Recommendations for string quotes, whitespace, and trailing commas. In this section, we’ll focus on style recommendations related to such things as:

string quotes;
whitespace in expressions and statements, and the use of trailing commas.
String quotes
Python allows us to use single-quoted (e.g., 'a string') and double-quoted (e.g., "a string") strings. They’re the same, and there’s no special recommendation in PEP telling you which style you should adopt in your code writing. Again, the most important rule is: be consistent with your choice.

However, to improve readability, PEP 8 recommends that you should try to avoid using backslashes (escape characters) in strings. This means that:

if your string contains single-quote characters, it’s recommended that you use double-quoted strings;
if your string contains double-quote characters, it’s recommended that you use single-quoted strings.
In the case of triple-quoted strings, PEP 8 recommends that you always use double-quote characters to maintain consistency with the docstring convention detailed in PEP 257 (we’re going to tell you more about this soon).

Whitespace in expressions and statements
PEP 8 contains a long section that shows examples of correct and incorrect uses of whitespace in code. Generally, you should avoid using too much whitespace, as it makes your code difficult to follow.

So, for example, do not use excessive whitespace immediately inside parentheses/brackets/braces, or immediately before a comma/semicolon/colon:

# Bad:
my_list = ( dog[ 2 ] , 5 , { "year": 1980 } , "string" )
if 5 in my_list : print( "Hello!" ) ; print( "Goodbye!" )

# Good:
my_list = (dog[2], 5, {"year": 1980}, "string")
if 5 in my_list: print("Hello!"); print("Goodbye!")

Whitespace in expressions and statements (cont.). In the case of a slice, the colon should have equal amounts of space on both sides (it should act like a binary operator) unless a slice parameter is omitted, in which case the space should be omitted, too.

Examples:

# Bad:
bread[0 : 3], roll[1: 3 :5], bun[3: 5:], donut[ 1: :5 ]


# Good:
bread[0:3], roll[1:3:5], bun[3:5:], donut[1::5]

Trailing commas
Again, do not use excessive whitespace:

after a trailing comma followed by a closing parenthesis, or
immediately before an opening parenthesis that marks the beginning of the argument list of a function invocation, or
immediately before an opening parenthesis that marks the beginning of indexing/slicing.
Examples:

# Bad:
my_tuple = (0, 1, 2, )
my_function (5)
my_dictionary ['key'] = my_list [index]

# Good:
my_tuple = (0, 1, 2,)
my_function(5)
my_dictionary['key'] = my_list[index]


Whitespace in expressions and statements (cont.). Don’t use more than one space before and after operators, e.g.:

# Bad:
a         = 1
b         = a        + 2
my_string = 'string' * 2

# Good:
a = 1
b = a + 2
my_string = 'string' * 2

Surround binary operators with a single space on both sides. However, if in your code there are operators that have different priorities, you may wish to consider adding spacing around the low(est) priority operators only, e.g.:

# Bad:
x=x+3
x -=1
x = x * 2 - 1
x = (x - 1) * (x + 2)

# Good:
x = x + 3
x -= 1
x = x*2 - 1  # Use your own judgement.
x = (x-1) * (x+2)  # Use your own judgement.

Don’t surround the = operator with spaces if it’s used to indicate a keyword argument/default value, e.g.:

# Bad:
def my_function(x, y = 2):
    return x * y

# Good:
def my_function(x, y=2):
    return x * y

Recommendations for using comments. Comments are meant to improve the readability of the code without affecting the output of the program. Good programmers document their code and explain the more complex code snippets, so that the person reading the code properly understands what’s going on in the program. You should use comments wisely, and whenever possible write code that will self-comment (e.g., give your variables, functions, and code elements proper names).

There are a few rules you should follow when leaving comments in code:

Write comments that will not contradict the code or mislead the reader. They’re much worse than no comment at all.
Update your comments when your program gets updated.
Write comments as complete sentences (capitalize the first word if it’s not an identifier, and end your sentence with a full stop). For example:
# Program that calculates body mass index (BMI).

height = float(input("Your height (in meters): "))
weight = float(input("Your weight (in kilograms): "))
bmi = round(weight / (height*height), 2)

print("Your BMI: {}".format(bmi))

When writing block comments with multi-sentence comments, use two spaces after each full stop ending a sentence, except after the final sentence.
Write comments in English (unless you are 100% sure that the code will never be read by people who don’t speak your language.)
Comments should consist of no more than 72 characters per line (but you know that already).

Block comments. Block comments are usually longer, and you should use them to explain sections of code rather than particular lines. They let you leave information for the reader in multiple lines (and multiple sentences). Generally, block comments:

should refer to the code that follows them;
should be indented to the same level as the code they describe.
When writing block comments, start each line with # followed by a single space, and separate paragraphs by a line that contains the # symbol only. For example:

def calculate_product():
    # Calculate the average of three numbers obtained from the user. Then 
    # multiply the result by 4.17, and assign it to the product variable.
    #
    # Return the value passed to the product variable and use it
    # for the subsequent x to y calculations to speed up the process.
    sum_numbers = 0
    
    for number in range(0, 3):
        number = float(input("Enter a number: "))
        sum_numbers += number
    
    average = (sum_numbers / 3) * 4.17
    product = average
    return product

x = product * 1.73
y = x ** 2
x_to_y = (x*y) / 1.05

Inline comments
Inline comments are comments that are written on the same line as your statements. They should address or provide further explanation to a single line of code or a single statement. You should not overuse them.

Generally, inline comments should be: 

separated by two (or more) spaces from the statement they address;
used sparingly.

They can quickly help you remember what a particular line of code does, or be useful when read by someone unfamiliar with your code. For example:

counter = 0     # Initialize the counter.

However, don’t use inline comments (or any other comments!) to explain obvious or unnecessary things. For example:

a += 1     # Increment a.

Always try making your code self-commenting rather than adding comments, even if they seem sensible or necessary, e.g.:

# Bad:
a = 'Adam'  # User's first name.

# Good:
user_first_name = 'Adam'

Documentation strings
Documentation strings, or docstrings as they’re often called, let you provide descriptions and explanations for all public modules, files, functions, classes, and methods you use in your code. You should use them in this context.

We’re going to deal with docstrings when we talk about PEP 257 later in the course. For the time being, you just need to remember that they’re a type of comment that begins and ends with three double quotes: """.

Examples:

# A multi-line docstring:
def fun(x, y):
    """Convert x and y to strings,
    and return a list of strings.
    """
    ...

# A single-line docstring:
def fun(x):
    """Return the square root of x."""
    ...

>>> 3.1.1.12 PEP 8 – Naming conventions





