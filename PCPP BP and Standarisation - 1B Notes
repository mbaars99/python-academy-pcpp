PCPP1: Best Practices and Standardization (Python Enhancement Proposals)

In this course, you will learn about:

PEP 20 (The Zen of Python)
PEP 8 (Style Guide for Python Code)
PEP 257 (Docstring conventions)
how to avoid common errors and mistakes when writing code;
how to write elegant and effective code.

What is PEP? PEP may refer to several things:

football (soccer) fans will definitely associate it with the famous ex-footballer and football manager, Josep Guardiola, whose nickname is (guess what) Pep;
those who have medical jobs will surely think of post-exposure prophylaxis, which in turn has to do with taking preventive medical measures after contact with pathogens;
physicians will think of the proton-proton chain reaction;
some older (?) gamers will visualize the image of Pep, the dog, a funny character from a popular children’s Atari computer game of the early nineties;
while Python programmers will immediately point to an online document, which outlines the language standards and provides information about many changes and processes related to Python.
In this module, as you may expect, we’re going to focus on the last of the many PEPs.

In the jungle of PEPs. There are many PEPs, hundreds of them. See PEP 0 -- Index of Python Enhancement Proposals (PEPs) to find out for yourself that they’re no idle words.
https://peps.python.org/

It would be remarkable, but unfortunately quite a challenge, to cover them all in this course. For this reason, we’ve picked four of them that deserve a closer analysis, and should be considered must-reads. These are:

PEP 1 – PEP Purpose and Guidelines, which provides information about the purpose of PEPs, their types, and introduces general guidelines;
PEP 8 – Style Guide for Python Code, which gives conventions and presents best practices for Python coding;
PEP 20 – The Zen of Python, which presents a list of principles for Python’s design;
PEP 257 – Docstring Conventions, which provides guidelines for conventions and semantics associated with Python docstrings.
We encourage you to dive into PEPs on your own. We’re sure you‘ll become more and more curious about them as your programming experience and awareness grow.

PEP 1 – PEP Purpose and Guidelines. PEP is an acronym that stands for Python Enhancement Proposals, which, in fact, is a collection of guidelines, best practices, descriptions of (new) features and implementations, as well as processes, mechanisms and important information surrounding Python.
Simply speaking, if a new feature is planned to be added to Python, it will be detailed in a PEP along with the technical specifications and the rationale for its implementation.
That’s what, among other things, PEP is for.

There are three different types of PEPs:
Standards Track PEPs, which describe new language features and implementations;
Informational PEPs, which describe Python design issues, as well as provide guidelines and information to the Python community;
Process PEPs, which describe various processes that revolve around Python (e.g., propose changes, provide recommendations, specify certain procedures).

PEP 1 – PEP Purpose and Guidelines (cont.)
PEPs are primarily addressed to Python developers and members of the Python community. They are maintained as text files in a repository, and can be accessed online at https://www.python.org/dev/peps/.

But did you know that you can propose your own PEP, too? If you have a new (brilliant) idea for Python, you are more than welcome to become your PEP’s champion, i.e., the one who writes a PEP proposal, puts it up for discussion in subject-related forums, and tries to reach a community consensus over it.
PEP formats, templates, and the submission process (including reporting bugs and submitting updates) as well as the subsequent stages: review, resolution, and maintenance, are all described in detail within PEP 1 – PEP Purpose and Guidelines. Feel free to quickly browse through it – you never know when you’re going to need it!

Last but not least, PEP 1 defines:
Python’s Steering Council, i.e., a five-person committee and the final authorities who accept or reject PEPs;
Python’s Core Developers, i.e., the group of volunteers who manage Python, and;
Python’s BDFL, i.e., Guido van Rossum, the original creator of Python, who served as the project’s Benevolent Dictator For Life until 2018, when he resigned from the decision-making process.

PEP 20 – The Zen of Python. The Zen of Python is a collection of 19 aphorisms, which reflect the philosophy behind Python, its guiding principles, and design.
Tim Peters, a long time major contributor to the Python programming language and Python community, wrote this 19-line poem on the Python mailing list in 1999, and it became entry #20 in the Python Enhancement Proposals in 2004. It’s one of the Easter eggs (i.e., hidden, secret messages or features) included in the Python interpreter. Now let’s see the magic. Go to the editor window, type in import this, run the code, and voilà! Can you see what happens?

import this
#output

The Zen of Python, by Tim Peters   

Beautiful is better than ugly.     
Explicit is better than implicit.  
Simple is better than complex.     
Complex is better than complicated.
Flat is better than nested.        
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!

What you see is a collection of some general truths for Python design rules and decision making. Even though the "poem" seems to be imbued with contradictions and allusions, we assure you that the aphorisms are extremely practical and common sense, and you’re encouraged to accept them and implement in your code.
These, of course, should be looked upon holistically, rather than individually, but, still, let’s try to meditate on each of them.

Beautiful is better than ugly. Beauty is a rather subjective experience. But, as Immanuel Kant said, the very esthetic experience of beauty is a judgement of human truth. And even though the computer doesn’t care about beauty or esthetics, people do, and we must remember that a nicely-written program is not only more enjoyable to read, but also more readable. Python has certain style rules that programmers are recommended to follow. These are, among other things: a 79-character maximum line length, variable naming conventions, placing statements on separate lines, and many others.

Example: Write a program that calculates the hypotenuse of a right-angled triangle.

#bad
from math import sqrt
sidea = float(input("The length of the 'a' side:"))
sideb = float(input("The length of the 'b' side:"))
sidec = sqrt(a**2+b**2)
print("The length of the hypotenuse is", sidec )

#better
from math import sqrt

side_a = float(input("The length of the 'a' side: "))
side_b = float(input("The length of the 'b' side: "))
hypotenuse = sqrt(a**2 + b**2)

print("The length of the hypotenuse is", hypotenuse)

Explicit is better than implicit. The code you write should be explicit and readable.
Whenever you want to use an implicit feature of the language, ask yourself whether you really need it. Maybe there’s a better way to implement the functionality. If not, think about leaving a comment in code to explain what’s going on so that other programmers find it easier to understand your code.
In Python, it’s preferred to use not only the simplest way to express a programming idea, but also the most explicit, concrete, specific one.

Explicit is better than implicit. Therefore, it’s sometimes a good idea to add more verbosity to your code as it all counts towards readability. Giving self-explanatory variable and function names, or adding more explicitness to imports or function arguments may be good practice.

Example: Import apples and bananas from the fruit.py module.

#bad
from fruit import *

apples(2, 3.45)

#better
from fruit import apples, bananas

apples(quantity=2, price=3.45)

Simple is better than complex. Simplicity is the key to success.
A simpler solution is usually preferred over a complex one, and generally, the minimalistic approach wins. Remember: use appropriate tools adjusted to the specificity of your project. Using a plane to transport yourself to a nearby shop could be okay (assuming you’re slightly eccentric), but usually it’d be enough to walk or drive. Similarly, you wouldn’t normally walk the distance if you wanted to travel from the UK to the USA. Taking a plane would be a more sensible idea here. Consider not adopting an object-oriented approach when it’s not needed. Use fewer lines of code if that’s possible.

If you need to implement a more complex solution, divide problems into smaller, simpler parts.

#bad
import heapq

numbers = [-1, 12, -5, 0, 7, 21, 15, 1]
heapq.heapify(numbers)

sorted_numbers = []

while numbers:
    sorted_numbers.append(heapq.heappop(numbers))

print(sorted_numbers)

#better
numbers = [-1, 12, -5, 0, 7, 21, 15, 1]
numbers.sort()

print(numbers)

Complex is better than complicated. When simple solutions are not possible, be aware of the limitations carried by simplicity, and use complex solutions instead.
Distinguishing between complex as consisting of many elements and complicated, meaning difficult to understand, is yet another thing to consider when writing code.
In other words, there are times when a complex solution may be preferred over a simple one, especially in the case of the latter causing misunderstanding, doubt, or misinterpretation. You should avoid those. On the other hand, complex is always preferred to complicated. When your code gets big and too difficult to understand and grasp, divide it into well-separated parts, so that it’s easier to manage and handle.

Avoid misunderstanding, lack of clarity, and miscomprehension.

Example: Perform five additions of two numbers.

#bad
first_number = int(input("Enter the first number: "))
second_number = int(input("Enter the second number: "))
addition_result = first_number + second_number
print(first_number, "+", second_number, "=", addition_result)
first_number = int(input("Enter the first number: "))
second_number = int(input("Enter the second number: "))
addition_result = first_number + second_number
print(first_number, "+", second_number, "=", addition_result)
first_number = int(input("Enter the first number: "))
second_number = int(input("Enter the second number: "))
addition_result = first_number + second_number
print(first_number, "+", second_number, "=", addition_result)
first_number = int(input("Enter the first number: "))
second_number = int(input("Enter the second number: "))
addition_result = first_number + second_number
print(first_number, "+", second_number, "=", addition_result)
first_number = int(input("Enter the first number: "))
second_number = int(input("Enter the second number: "))
addition_result = first_number + second_number
print(first_number, "+", second_number, "=", addition_result)

#better
def addition(x, y):
    print(x, "+", y, "=", x+y)

for i in range(5):
    first_number = int(input("Enter the first number: "))
    second_number = int(input("Enter the second number: "))
    addition(first_number, second_number)

Flat is better than nested. Nesting code makes it more difficult to follow and understand. Nesting two or three levels deep may still be good, but anything beyond that becomes confusing and unreadable. Even though you can actually have any level of nested loops or if statements in Python, anything above three should be a clear signal that it’s maybe a good time to start refactoring your code. Flat code is more user-friendly, and becomes much easier to maintain. Remember this.

Example: Display a message whether or not x is within the range from 4 to 6.

#bad
x = float(input("Enter a number: "))

if x > 0:
    if x > 1:
        if x > 2:
            if x > 3:
                if x >= 4:
                    if x <= 6:
                        print("x is a number between 4 and 6.")
else:
    print("x is not a number between 4 and 6.")

#better
x = float(input("Enter a number: "))

if x >= 4 and x <=6:
    print("x is a number between 4 and 6.")
else:
    print("x is not a number between 4 and 6.")

Flat is better than nested. Nesting code makes it more difficult to follow and understand. Nesting two or three levels deep may still be good, but anything beyond that becomes confusing and unreadable. Even though you can actually have any level of nested loops or if statements in Python, anything above three should be a clear signal that it’s maybe a good time to start refactoring your code. Flat code is more user-friendly, and becomes much easier to maintain. Remember this.

Example: Display a message whether or not x is within the range from 4 to 6.

#bad
x = float(input("Enter a number: "))

if x > 0:
    if x > 1:
        if x > 2:
            if x > 3:
                if x >= 4:
                    if x <= 6:
                        print("x is a number between 4 and 6.")
else:
    print("x is not a number between 4 and 6.")

#better
x = float(input("Enter a number: "))

if x >= 4 and x <=6:
    print("x is a number between 4 and 6.")
else:
    print("x is not a number between 4 and 6.")

Sparse is better than dense. Don’t write too much code in one line, don’t fit too much information into a small amount of code, don’t write lines of code that are too long, use whitespaces responsibly – this all affects the readability and understanding of your program. The easiest and most common way to introduce sparsity to your code is to introduce nesting. That’s probably why this aphorism comes right after the one which tells us to prefer flat code over nested code. The key to readability is to strike a balance between the two: reduce nesting, then try to reduce density.

Example: Print the message “Hello, World!” if the value passed to the x variable equals 1.

#bad
x = 1
if x == 1 : print("Hello, World!")

#better
x = 1
if x == 1:
    print("Hello, World!")

Readability counts. Your code is not only read by computers, it’s also (or most of all) read by humans. In fact, it’s the essence of the Python philosophy, and the whole of Python design and culture actually revolves around the very statement that “code is read more often than it is written” (Guido Van Rossum).
All the previous aphorisms (and the subsequent ones) pave the way to readability, to a lesser or greater extent, as one of the most crucial factors that should be kept in mind while creating code. Whenever you feel tempted to give up on readability, the reason be it saving time by having to think up meaningful names, the effort taken to format your code, or any other reason – reject the temptation. Don’t underestimate the power of readability, especially when you have to return to your code after some time, or leave the code for others to develop in the future. Giving meaningful names to variables, functions, modules, and classes; properly styling blocks of code; using comments where necessary; keeping your code neat and elegant – these all contribute to how readable and user-friendly your code is.

Remember: the readability of your code reflects how responsible a programmer you are. It not only reflects well on the quality of the code, it reflects well on its author.

Example: Write a program that calculates a product’s gross price.

#bad
def f(i):
    l = i + (0.08 * i)
    return l

# better
# Calculates the gross price of products in Wonderland.
def calculate_gross_price(net_price):
    gross_price = net_price + (0.08 * net_price)
    return gross_price

Special cases aren't special enough to break the rules... Discipline, consistency, and compliance with standards and conventions are all important elements in professional and responsible code development. There should be no exceptions that allow us to break the principles governing best coding practices.
No special cases such as time pressure or complexity of a given problem should be an excuse for writing code that does not follow the guidelines.
It’s not only about readability, though it should be one of the first things you think about, but it’s also about sticking to the design and development-related decisions you’ve made, be it consistency which can ensure backward compatibility, keeping naming conventions unchanged, or anything else.

Example: Write a function that multiplies two numbers and a function that adds two numbers.

#bad
def multiply_two_numbers(first_number, second_number):
    return first_number * second_number

print(multiply_two_numbers(7, 9))

def addingTwoNumbers(firstNumber, secondNumber):
    return firstNumber + secondNumber

print(addingTwoNumbers(7, 9))

#better
def multiply_two_numbers(first_number, second_number):
    return first_number * second_number

print(multiply_two_numbers(7, 9))

def add_two_numbers(first_number, second_number):
    return first_number + second_number

print(add_two_numbers(7, 9))

...Although, practicality beats purity. Okay… what’s going on here? The previous aphorism encouraged us to never break the rules, while this one says there might be some exceptions to this. Why? Well, we must remember that the ultimate goal is to solve real problems and write code that performs some particular (expected) task. If your code is elegant, readable, and complies with all the important styling conventions, but does not function the way it should, then it doesn’t make much sense, does it?

If the possible benefits (e.g., better performance) are larger than the possible negative effects (e.g., affected maintainability), the real-world coding problems may find an excuse for making an exception to the rules. Practicality then becomes more important than purity.

If you need to write an 85-character long line of code because splitting it into two separate lines affects readability, do it. If you need to keep compatibility with previously written code and use CamelCase instead of snake_case, do it. Rules sometimes have to be broken, exceptions have to be made.

Errors should never pass silently..."...Unless explicitly silenced." Analyze a potentially dangerous situation below:

number = input("Enter a number: ")
multiply_number_by_two = number * 2

print("Your number multiplied by two is:", multiply_number_by_two)

Let’s assume that the programmer has forgotten to convert the value assigned to the number variable to int or float. The program will not crash. On the contrary, it will run without any problems and output a fine result. Although, far from expected. If the snippet constitutes just a tiny part of the whole code, the programmer might have difficulty finding the source of an error and debugging the program as no explicit error message is displayed in the console.
Let’s make some changes and improve the snippet a bit:

number = int(input("Enter a number: "))
multiply_number_by_two = number * 2

print("Your number multiplied by two is:", multiply_number_by_two)

What happens when the user enters 3.5 or two as the input? Well, Python will of course loudly inform you that there’s been something wrong: it will raise the ValueError exception. The Python language provides a very good mechanism for error handling, with a number of built-in exceptions, and a great toolset for creating user-defined exception handling systems. The Zen of Python gently reminds us that if a block of code is unable to perform its function and work in the way that is expected by the programmer, it should terminate the program and/or loudly announce that something has gone wrong (i.e., raise an exception) rather than continue running without interruption.

A program that crashes is easier to debug than a program that silences an error. Raising an exception draws your attention to the issue and provides important information about what happened and why. Errors which pass silently may infect the program and change its operation so that it becomes unpredictable, unexpected, and undesired.

One of the most difficult jobs a programmer needs to do is to think of all the possible contexts (or at least as many of them as possible) in which an exception may occur. Serving these exceptions and providing a remedy for expected (and well-handled) errors is an important challenge, but at the same time a crucial responsibility of a good, professional programmer.

Example: An explicitly silenced error (using the except keyword). However, the exception is too broadly handled:

try:
    print(1/0)
except Exception as e:
    pass

An improved version, handling a specific kind of an error:

try:
    print(1/0)
except ZeroDivisionError:
    print("Don't divide by zero!")

Well, naturally there may be situations where you don’t want to shout “Hey! There’s an error!” but rather handle it in a subtle way and not necessarily make a fuss about it. Analyze the code below in which we handle an exception by adding a default value:

try:
    number = int(input("Enter an integer number: "))
except:
    number = 0

In the face of ambiguity, refuse the temptation to guess. Guesses will surely work in many cases, but in many others they may bitterly disappoint you. This guideline conveys a twofold message: on the one hand, it tells you to have limited trust in the code you’re writing, while on the other hand, it implies that you should have limited trust in the code you’re reading. But what does that mean?

The first thing to remember is to always test your code before releasing it to production and deploying it to customers. Sounds obvious and reasonable? Well, yes, but many times programmers neglect or forget about this simple habit, be it because they trust their coding skills to the extent they, for example, reject any possibility of making typos, or because they work under great time pressure and feel they have no time for testing.

An important thing to keep in mind is: testing your code allows you to save time, not waste it. If you find a bug at an early stage, it will cost you less time and money to fix it. If you don’t test your code and it turns out there’s a bug at an advanced stage of development, corrections may be a pretty expensive and time-consuming enterprise.

Another thing is that you should avoid writing ambiguous code, which means you should leave no room for guessing. Give your variables self-commenting names, and leave comments where necessary. If you’re importing a module, make the import an explicit one. If a particular snippet is complex or complicated, explain its functioning. Never leave comments or use names that are wrong, confusing or misleading!

By the same token, if you suspect there’s something wrong in the code you’re reading, or feel there’s something unclear in it, do not guess its operation – test it!

Let’s analyze the following example:

fun(1, 2, 3)
fun(a=1, b=2, c=3)


The two function invocations may be the same, but not necessarily. It’s not possible to know without seeing the function definition. If the function definition is like the one below, the results could differ:

def fun(x=0, y=0, z=0, a=1, b=2, c=3):
    pass

Let’s take a look at one more example:

print("A" > "a")
print(1.0 == 1)
print("1" == 1)
print(True == "1")
print(True == 1)
print(True == 1.0)
print("1" + "1")
print(1 + 1)
print(1 + "1")

Do you know the result of the above snippet? Are you certain, or are you guessing? Would the above comparisons and expressions provide the same results across different programming languages? Well, not necessarily... If you’re working on a program that accepts data from the user, don’t rely on your guesses, because what you assume to be the most common may turn out to be the least common when faced with real-life data.

For example, if you’re writing an app that accepts text from the user, specify what encoding you expect from them, and accept only this particular encoding, handling all the cases the expected encoding is not providing. If you need to perform a conversion, use specialized, valid tools for that to avoid character garbling or program crashes. Always remember to look for the contexts in which your program might crash, and serve them. Don’t rely on your guesses or conviction that the user will strictly follow your instructions. Analyze the fragment of a simple interactive Python session we’ve provided below. Can you see what went wrong?

>>> integer_number = int(input("Enter an integer number: "))
Enter an integer number: 15.6
Traceback (most recent call last):
  File "<pyshell#4>", line 1, in <module>
    integer_number = int(input("Enter an integer number: "))
ValueError: invalid literal for int() with base 10: '15.6'

2.1.1.13 PEP 20 – The Zen of Python

There should be one – and preferably only one – obvious way to do it. “Although that way may not be obvious at first unless you're Dutch.”

There may be multiple ways of achieving the same goal. For example, if you want to take the user’s first name and last name, and display them on the screen, you can do it in one of the following ways:

first_name = input("Enter your first name: ")
last_name = input("Enter your last name: ")

print("Your name is:", first_name, last_name)
print("Your name is:" + " " + first_name + " " + last_name)
print("Your name is: {} {}".format(first_name, last_name))

Which one of them is the preferred one? It depends on what you want to achieve, how you want to format the outputted text, what past conventions were used, etc.

It seems there’s nothing wrong with having multiple ways to do a certain thing, as long as we’re ready for confrontation, and are able to agree on the best way to achieve a particular goal. 

The guideline also reminds us that it’s a good idea to follow the language use standards and conventions. For example, if you’ve been using snake_case to name your variables in your code so far, it may be a bad idea to start using CamelCase for the rest of your code within one and the same program. Well, unless you do this for a specific purpose, and the advantages of such an approach are bigger than the disadvantages.

Finally, the aphorism works as a gentle indication of yet another important piece of advice: where possible, it’s good to remember that each function, each class, each method – each entity – should have a single cohesive responsibility. Why? Because such an approach helps you gain more clarity and produce cleaner code, makes it easier and cheaper to maintain it, and less vulnerable to bugs.

When it comes to the second part of the aphorism, on the one hand it is meant to be a joke: the Dutch surely have a different way of thinking, different worldview, and different way of getting down to doing things (you certainly remember that Guido van Rossum is Dutch, too).

On the other hand, however, it indicates that working out how to obtain the best solution can be a long and challenging process: one obvious way to do something may not necessarily be obvious at first. Finding a relevant and preferred solution may require time, effort, and changing certain habits.

Python itself is a good example of this – it’s still evolving, its features and the ideas around it are changing, and Python programmers may still perceive relatively similar things differently.

What’s the best way to access values in a dictionary: using the get() method, or the syntax my_dict['key'], or some other way? What’s the best way to read a file: block by block, line by line? What’s the best way to print the user’s first and last names on the screen…?

Now is better than never. “Although never is often better than *right* now.”

You should not put off till tomorrow what you can do today. It’s a well-known proverb. Why? Well, because there’s never a good time for anything – there are always some “buts” and “ifs” which tell you to wait longer and delay things. Before you actually get down to doing these things – writing your code – you may have forgotten the ideas or information you need to do it well.

Python lets you quickly translate your ideas into working code. Whenever you experience the eureka effect or have your moment of inspiration, write down your thoughts and encode them in Python (or at least use some form of pseudocode) – even if your code is far from perfect. You can later refine, develop, or redesign it very easily.

Another thing to remember is that there is no such thing as a perfect thing. You can work hard to move closer to perfection, refine your code, refactor it several times, but it will never be perfect. No single thing can, and you must be aware of that. If you give in to temptation to complete a program and release it only when it’s perfect, it’s highly probable you will never do it.

Your program has the expected functioning? It passes all the tests? Maybe it’s ready for the world to see it?

On the other hand, the aphorism tells us not to forget about the proper balance. Just as perfect is the enemy of good, it often turns out that faster is the enemy of slower. There are cases when things should not be rushed.

Your function’s not working as expected and you cannot fix it today? Mark it as deprecated so that you don’t forget about it:

def deprecated_function():
    raise DeprecationWarning

Your project needs to go through the testing stage? Do you need to collect feedback from the users? The marketing campaign is not ready yet? Take the time to get everything right and release the product when it’s really ready, not when it looks ready.

If the implementation is hard to explain, it's a bad idea. “If the implementation is easy to explain, it may be a good idea.”
Everything and anything that can be explained in words can be translated into code, and eventually turned into a well-operating computer program.

If you can explain what you expect from a program, what you want it to do – such a program can be designed. If you find it difficult to explain its features and functionality, it may be a signal that maybe your idea should be thought over again and digested.

Simplicity and minimalism are the keys again (though such ones that don’t kill readability). Simple is better than complex, but complex is better than complicated – if you’ve already forgotten, here’s a subtle reminder. Keep things simple; the simpler, the better.

However, even though something’s easy to explain, it doesn’t mean it’s good. It’s just easier to judge whether it is or not. When you’re in doubt, have your implementation reviewed by your peers and see how much effort it takes them to grasp the idea and understand the whole concept. Another pair of eyes can cast new light on your project and help you see it in a new way.

Namespaces are one honking great idea – let's do more of those! Python provides a good, well-organized namespace mechanism to manage the availability of identifiers that you want to use and avoid conflicts with already existing names across different scopes.

What is a namespace? Generally speaking, it’s “a mapping from names to objects” (https://docs.python.org/3/tutorial/classes.html) implemented in Python in the form of a dictionary. What does it mean? Simply speaking, it means that whenever you define a variable, Python “remembers” two things: the variable’s identifier, and the value you pass to it.

How does it happen? Python implicitly adds them to an internal dictionary which resides within a particular scope, i.e., the region of a Python program where namespaces are accessible. If you want to access that variable, Python looks up its name in the dictionary and returns the value passed to it. If the variable doesn’t exist and, hence, isn’t found, then it raises the NameError exception.

Functions, classes, objects, modules, packages… they’re all namespaces. This fact results in the following: a more specific namespace cannot be altered by a less specific namespace, as they reside within two different scopes (e.g., a local variable inside a function doesn’t influence a global variable*). However, a more specific namespace has access to a less specific namespace (e.g., a global variable can be accessed from within a function).

*Using the global keyword before a global variable inside the function is a mechanism that allows you to alter that variable, even though it resides in a different scope (bad practice).

Use the namespaces to make your code clearer and more readable. For example, do this:

from instruments import guitars

guitars.fender(page)
guitars.ibanez(vai)

Instead of this:

from instruments.guitars import fender, ibanez

fender(page)
ibanez(vai)

Why? Because the first example will clearly show that fender and ibanez come from a different module, not from within the local scope.

Introduction to PEP 8. As mentioned earlier, PEP 8 is a document that provides coding conventions (code style guide) for Python code.

PEP 8 is considered one of the most important PEPs and a must-read for every professional Python programmer, as it helps to make the code more consistent, more readable, and more efficient.

Even though some programming projects may adopt their own style guidelines (in which case such project-specific guidelines may be favored over the conventions provided for by PEP 8, especially in the case of any conflicts, or backwards-compatibility issues), the PEP 8 best practices are still highly recommended reading, as they help you to better understand the philosophy behind Python and become a more aware and proficient programmer.

PEP 8 is still evolving as new, additional conventions are being identified and included in it, and at the same time some old conventions are being identified as obsolete and discouraged from being followed.

The Hobgoblin of Little Minds. ”A foolish consistency is the hobgoblin of little minds.” This is a quote from Ralph Waldo Emerson’s essay “Self-Reliance” where Emerson urges readers to be consistent in their beliefs and practices. In our case, it means we must not forget about one simple but important observation: our code will be read much more often than it will be written.

On the one hand, consistency is a crucial factor that determines code readability. On the other hand, inconsistency with PEP 8 may at times be a better option. If the style guides are not applicable to your project, it may be better to ignore them and decide for yourself what is best. As PEP 8 says:

A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important. [...] However, know when to be inconsistent [...]. When in doubt, use your best judgement.

When should you ignore some specific PEP 8 guidelines (or at least consider doing so)?

If following them will mean that you break backwards compatibility.
If following them will have a negative effect on code readability.
If following them will cause inconsistency with the rest of the code. (However, this may be a good opportunity to rewrite the code and make it PEP 8 compliant.)
If there is no good reason for making the code PEP 8 compliant, or the code predates PEP 8. PEP 8 is intended to improve code readability and “make it consistent across the wide spectrum of Python code.” Keeping your Python code compliant with PEP 8 is, therefore, a good idea, but you should never blindly adhere to these recommendations. You should always use your best judgement.

PEP 8 compliant checkers. There are many useful tools that can help you validate your code style and check it against PEP 8 style conventions. These tools can be installed and run locally, or accessed online. We want to show you just two of them, but we encourage you to explore further on your own:

pycodestyle (formerly called pep8, but the name was changed to avoid confusion) - Python style guide checker; it lets you check your Python code for conformance with the style conventions in PEP 8. You can install the tool with the following command in the terminal:

$ pip install pycodestyle

You can run it on a file or files to obtain information about non-conformance (and indicate errors in the source code and their frequency).

More information: https://github.com/PyCQA/pycodestyle
Documentation: https://pycodestyle.pycqa.org/en/latest/

You can also install autopep8 to automatically format your Python code to conform to the PEP 8 guidelines. To be able to use it, you need the pycodestyle installation on your machine in order to indicate those parts of the code which require formatting fixes.

More information: https://pypi.org/project/autopep8/

PEP 8 online is an online PEP 8 checker created by Valentin Bryukhanov which lets you paste your code or upload a file, and validate it against the PEP 8 style guidelines. The online tool is built using Flask, Twitter Bootstrap, and the PEP8 module (the very same module we’ve just described).

More information: http://pep8online.com/about >>> seems down. google found: https://www.codewof.co.nz/style/python3/

Recommendations for Code Layout
PEP 8 is supposed to make your coding experience better and your life a whole lot easier. As stated before, the way you write your code has a big impact on its readability. However, you should not forget it can determine its syntactic legality, too.

In this section, we’ll focus on style recommendations related to such things as:

indentation, using tabs and spaces;
line length, line breaks, and blank lines;
source file encoding and module imports.
Indentation
The indentation level, understood as the leading whitespace (i.e., spaces and tabs) at the beginning of each logical line, is used to group statements.

When writing code in Python, you should remember to follow these two simple rules:

Use four spaces per indentation level, and;
Use spaces rather than tabs.
However, you can use tabs when you wish to keep consistency with code that has already been indented with tabs (if it’s not possible or efficient to make it PEP 8 compliant).

Note: Mixing tabs and spaces for indentation is not allowed in Python 3. This will raise a TabError exception: “TabError: inconsistent use of tabs and spaces in indentation”.

Examples:

# Bad:
def my_fun_one(x, y):
    return x * y

def my_fun_two(a, b):
  return a + b

# Good:
def my_function(x, y):
    return x * y

Continuation lines. Continuation lines (i.e., logical lines of code that you want to split because they’re too long or because you want to improve readability) are allowed if using parentheses/brackets/braces:

# Bad:
my_list_one = [1, 2, 3,
    4, 5, 6
]

a = my_function_name(a, b, c,
    d, e, f)

# Good:
my_list_one = [
    1, 2, 3,
    4, 5, 6,
    ]

a = my_function_name(a, b, c,
                       d, e, f)

# Good:
my_list_two = [
    1, 2, 3,
    4, 5, 6,
]

def my_fun(
        a, b, c,
        d, e, f):
    return (a + b + c) * (d + e + f)


You can read more about indentation in the context of continuation lines at https://www.python.org/dev/peps/pep-0008/#indentation.

Maximum Line Length and Line Breaks
If possible, you should limit all lines to a maximum of 79 characters as this will help you avoid wrapping several lines of code. If line wrapping is inevitable, use Python’s implied line continuation from the previous page.

In the case of docstrings and comments, the line length should not exceed 72 characters. Max line length and line breaks

For convenience, if agreed by a team (or teams) working on a given project, according to PEP 8, it’s possible to increase the line length to 99 characters (this does not relate to docstrings/comments, whose line length should still remain limited to 72 characters).

Still, the Python Standard Library is conservative in this matter, and requires you to use no more than 79 characters per line (72 for comments/docstrings).

Line breaks and operators
Even though in Python you’re allowed to break code lines before or after binary operators (providing you do so consistently and that this convention has been used in your code before), it is recommended that you follow Donald Knuth’s style suggestions and break before binary operators as this results in a more readable, eye-friendly code.

Example:
# Recommended

total_fruits = (apples
                + pears
                + grapes
                - (black currants - red currants)
                - bananas
                + oranges)

Blank Lines. Blank lines, called vertical whitespaces, improve the readability of your code.

They allow the person reading your code to see the division of the code into sections, help them better understand the relation between the sections, and grasp the logic of given blocks of code more easily. In the same fashion, using too many blank lines in your code will make it look sparse and more difficult to follow, which is why you must always be careful not to overuse them.

PEP 8 recommends that you should use:

– two blank lines to surround top-level function and class definitions:

class ClassOne:
    pass

Class ClassTwo:
    pass

def my_top_level_function():
    return None
– a single blank line to surround method definitions inside a class:

class MyClass:
    def method_one(self):
        return None

    def method_two(self):
        return None


– blank lines in functions in order to indicate logical sections (sparingly). For example:

def calculate_average():
    how_many_numbers = int(input("How many numbers? "))
    
    if how_many_numbers > 0:
        sum_numbers = 0
        for i in range(0, how_many_numbers):
            number = float(input("Enter a number: "))
            sum_numbers += number

        average = 0
        average = sum_numbers / how_many_numbers

        return average
    else:
        return "Nothing happens."

Default encodings. It is recommended that you use Python’s default encodings (Python 3 -- UTF-8, Python 2 -- ASCII). Non-default encodings are discouraged and should only be used for test purposes or in situations where your comments or docstrings use a name (e.g., an author’s name) that contains a non-ASCII character.
PEP 8 states that “all identifiers in the Python standard library MUST use ASCII-only identifiers, and SHOULD use English words whenever feasible".

Note: See PEP 3131 (Supporting Non-ASCII Identifiers) for more information about the rationale as well as the pros and cons of using non-ASCII identifiers.

Imports. You should always put imports at the beginning of your script, between module comments/docstrings and module globals and constants, respecting the following order:

Standard library imports;
Related third-party imports;
Local application/library specific imports.
Make sure you insert a blank line to separate each of the above groups of imports.

PEP 8 recommends that your imports be on separate lines, rather than squeezed onto one line:

# Bad:
import sys, os

# Good:
import os
import sys

Still, it’s correct to make a one-line import using the from … import … syntax:

from subprocess import Popen, PIPE. If possible, use absolute imports (i.e., imports that use absolute paths separated by full stops). For example:

import animals.mammals.dogs.puppies

Such imports are preferred in Python, especially when your application is not overgrown or extremely complex.

You shouldn’t (and actually you cannot) use implicit relative imports, as these are no longer present in Python 3. You should also avoid using wildcard imports, for example:

from animals import *

as they inhibit code readability and may interfere with some of the names already present in the namespace.

Recommendations for string quotes, whitespace, and trailing commas. In this section, we’ll focus on style recommendations related to such things as:

string quotes;
whitespace in expressions and statements, and the use of trailing commas.
String quotes
Python allows us to use single-quoted (e.g., 'a string') and double-quoted (e.g., "a string") strings. They’re the same, and there’s no special recommendation in PEP telling you which style you should adopt in your code writing. Again, the most important rule is: be consistent with your choice.

However, to improve readability, PEP 8 recommends that you should try to avoid using backslashes (escape characters) in strings. This means that:

if your string contains single-quote characters, it’s recommended that you use double-quoted strings;
if your string contains double-quote characters, it’s recommended that you use single-quoted strings.
In the case of triple-quoted strings, PEP 8 recommends that you always use double-quote characters to maintain consistency with the docstring convention detailed in PEP 257 (we’re going to tell you more about this soon).

Whitespace in expressions and statements
PEP 8 contains a long section that shows examples of correct and incorrect uses of whitespace in code. Generally, you should avoid using too much whitespace, as it makes your code difficult to follow.

So, for example, do not use excessive whitespace immediately inside parentheses/brackets/braces, or immediately before a comma/semicolon/colon:

# Bad:
my_list = ( dog[ 2 ] , 5 , { "year": 1980 } , "string" )
if 5 in my_list : print( "Hello!" ) ; print( "Goodbye!" )

# Good:
my_list = (dog[2], 5, {"year": 1980}, "string")
if 5 in my_list: print("Hello!"); print("Goodbye!")

Whitespace in expressions and statements (cont.). In the case of a slice, the colon should have equal amounts of space on both sides (it should act like a binary operator) unless a slice parameter is omitted, in which case the space should be omitted, too.

Examples:

# Bad:
bread[0 : 3], roll[1: 3 :5], bun[3: 5:], donut[ 1: :5 ]


# Good:
bread[0:3], roll[1:3:5], bun[3:5:], donut[1::5]

Trailing commas
Again, do not use excessive whitespace:

after a trailing comma followed by a closing parenthesis, or
immediately before an opening parenthesis that marks the beginning of the argument list of a function invocation, or
immediately before an opening parenthesis that marks the beginning of indexing/slicing.
Examples:

# Bad:
my_tuple = (0, 1, 2, )
my_function (5)
my_dictionary ['key'] = my_list [index]

# Good:
my_tuple = (0, 1, 2,)
my_function(5)
my_dictionary['key'] = my_list[index]


Whitespace in expressions and statements (cont.). Don’t use more than one space before and after operators, e.g.:

# Bad:
a         = 1
b         = a        + 2
my_string = 'string' * 2

# Good:
a = 1
b = a + 2
my_string = 'string' * 2

Surround binary operators with a single space on both sides. However, if in your code there are operators that have different priorities, you may wish to consider adding spacing around the low(est) priority operators only, e.g.:

# Bad:
x=x+3
x -=1
x = x * 2 - 1
x = (x - 1) * (x + 2)

# Good:
x = x + 3
x -= 1
x = x*2 - 1  # Use your own judgement.
x = (x-1) * (x+2)  # Use your own judgement.

Don’t surround the = operator with spaces if it’s used to indicate a keyword argument/default value, e.g.:

# Bad:
def my_function(x, y = 2):
    return x * y

# Good:
def my_function(x, y=2):
    return x * y

Recommendations for using comments. Comments are meant to improve the readability of the code without affecting the output of the program. Good programmers document their code and explain the more complex code snippets, so that the person reading the code properly understands what’s going on in the program. You should use comments wisely, and whenever possible write code that will self-comment (e.g., give your variables, functions, and code elements proper names).

There are a few rules you should follow when leaving comments in code:

Write comments that will not contradict the code or mislead the reader. They’re much worse than no comment at all.
Update your comments when your program gets updated.
Write comments as complete sentences (capitalize the first word if it’s not an identifier, and end your sentence with a full stop). For example:
# Program that calculates body mass index (BMI).

height = float(input("Your height (in meters): "))
weight = float(input("Your weight (in kilograms): "))
bmi = round(weight / (height*height), 2)

print("Your BMI: {}".format(bmi))

When writing block comments with multi-sentence comments, use two spaces after each full stop ending a sentence, except after the final sentence.
Write comments in English (unless you are 100% sure that the code will never be read by people who don’t speak your language.)
Comments should consist of no more than 72 characters per line (but you know that already).

Block comments. Block comments are usually longer, and you should use them to explain sections of code rather than particular lines. They let you leave information for the reader in multiple lines (and multiple sentences). Generally, block comments:

should refer to the code that follows them;
should be indented to the same level as the code they describe.
When writing block comments, start each line with # followed by a single space, and separate paragraphs by a line that contains the # symbol only. For example:

def calculate_product():
    # Calculate the average of three numbers obtained from the user. Then 
    # multiply the result by 4.17, and assign it to the product variable.
    #
    # Return the value passed to the product variable and use it
    # for the subsequent x to y calculations to speed up the process.
    sum_numbers = 0
    
    for number in range(0, 3):
        number = float(input("Enter a number: "))
        sum_numbers += number
    
    average = (sum_numbers / 3) * 4.17
    product = average
    return product

x = product * 1.73
y = x ** 2
x_to_y = (x*y) / 1.05

Inline comments
Inline comments are comments that are written on the same line as your statements. They should address or provide further explanation to a single line of code or a single statement. You should not overuse them.

Generally, inline comments should be: 

separated by two (or more) spaces from the statement they address;
used sparingly.

They can quickly help you remember what a particular line of code does, or be useful when read by someone unfamiliar with your code. For example:

counter = 0     # Initialize the counter.

However, don’t use inline comments (or any other comments!) to explain obvious or unnecessary things. For example:

a += 1     # Increment a.

Always try making your code self-commenting rather than adding comments, even if they seem sensible or necessary, e.g.:

# Bad:
a = 'Adam'  # User's first name.

# Good:
user_first_name = 'Adam'

Documentation strings
Documentation strings, or docstrings as they’re often called, let you provide descriptions and explanations for all public modules, files, functions, classes, and methods you use in your code. You should use them in this context.

We’re going to deal with docstrings when we talk about PEP 257 later in the course. For the time being, you just need to remember that they’re a type of comment that begins and ends with three double quotes: """.

Examples:

# A multi-line docstring:
def fun(x, y):
    """Convert x and y to strings,
    and return a list of strings.
    """
    ...

# A single-line docstring:
def fun(x):
    """Return the square root of x."""
    ...

Naming conventions – Introduction. When programming, you often have to name identifiers and other entities in your code. Giving suitable names and avoiding inappropriate ones will definitely increase your code readability and save you (and other programmers reading your code) a lot of time and effort.
You most certainly already follow some conventions for giving names to variables, functions, and classes in your code; some of them may come from your former programming experience in other languages, others may be a purely practical choice, while still others may be determined by the project requirements or practices adopted by your company or team.
Python naming conventions are, unfortunately, not fully consistent throughout the Python library. However, it is recommended that new modules and packages be written in compliance with the PEP 8 naming recommendations (unless an existing library follows a different style, in which case internal consistency is the preferred solution).

Naming styles. There are many different naming styles used in programming, for example:

a – single lowercase letter
A – single uppercase letter

Generally, you should avoid using single-letter names like l (the lowercase letter el), I (the uppercase letter eye), and O (the uppercase letter oh), because they can easily be mistaken for the numbers 1 and 0, and make your code much less readable.

mysamplename – lowercase
my_sample_name – lowercase with underscores (snake_case)
MYSAMPLENAME – uppercase
MY_SAMPLE_NAME – uppercase with underscores (SNAKE_CASE)

MySampleName – CamelCase (also known as capitalized words, StudlyCaps, or CapWords). A short note: when you use acronyms, you should capitalize all the letters that make up the acronym, e.g., HTTPServerError

mySampleName – mixed case, which actually differs from CamelCase only by having an initial lowercase character. My_Sample_Name – capitalized words with underscores (considered ugly by PEP 8)

_my_sample_name – a name that starts with a single leading underscore indicates a weak "internal use", e.g., the instruction from SAMPLE import * will not import objects whose names start with an underscore.

my_sample_name_ -– a single trailing underscore is used by convention in order to avoid any conflicts with Python keywords, e.g., class_

__my_sample_name – a name that starts with a double leading underscore is used for class attributes where it invokes name mangling, e.g., inside the class MySampleClass, __room will become _MySampleClass__room

__my_sample_name__ – a name that starts and ends with a double underscore is used for "magic" objects and attributes that reside in user-controlled namespaces, e.g., __init__, __import__, or __file__. You shouldn't create such names, but only use them as documented.

Naming conventions – recommendations. PEP 8 provides for a specific naming convention with regard to a specific identifier.

When giving a name to a variable, you should use a lowercase letter or word(s), and separate words by underscores, e.g., x, var, my_variable. The same convention applies to global variables.

Functions follow the same rules as variables, i.e., when giving a name to a function, you should use a lowercase letter or word(s) separated by underscores, e.g., fun, my_function.

When giving a name to a class, you should adopt the CamelCase style, e.g., MySampleClass, or if there's only one word, start it with a capital letter, e.g., Sample.

When giving a name to a method, you should use a lowercase word or words separated by underscores, e.g., method, my_class_method. You should always use self for the first argument to instance methods, and cls for the first argument to class methods.

When giving a name to a constant, you should use uppercase letters and separate words by underscores, e.g., TOTAL, MY_CONSTANT.

When giving a name to a module, you should use a lowercase word or words, preferably short, and separate them with underscores, e.g., samples.py, my_samples..

When giving a name to a package, you should use a lowercase word or words, preferably short ones. You shouldn't separate words, e.g., package, mypackage.

Type variable names should follow the CamelCase convention and be short, e.g., AnyStr, or Num.

When giving a name to an exception, you should follow the same convention as with classes (bear in mind that exceptions should actually be classes), i.e., use the CamelCase style.

Note: You can use a different style, e.g., mixed case (mySample) for functions and variables, but only if this helps to retain backwards compatibility, and if that's the prevailing style.

For more detailed information about PEP 8 naming conventions, go to the PEP 8 official page: https://www.python.org/dev/peps/pep-0008/#prescriptive-naming-conventions.

Programming recommendations. There are often multiple ways of writing code that will perform the same action in Python, however PEP 8, again, imposes certain conventions and provides tips as to how you should follow the best programming practices to avoid ambiguity, keep consistency with your previous code and Python libraries, and achieve better code performance/efficiency.

Here they are:
– make comparisons to the None object with the use of is or is not, not with the (in)equality operators (== and !=), e.g.:

# Bad:
if x == None:
    print("A")

What's the difference?
is checks for identity — are both sides pointing to the exact same object in memory?
== checks for equality — do the values happen to be equal?
In most cases x == None works, but it can behave unexpectedly if x is an object that overloads the __eq__ method. 
So to be precise, safe, and clear when checking for None, always use is or is not.
Why? Because None is a singleton — there is only one instance of None in a Python program. You’re not comparing values, you're checking whether a variable is that exact object.

# Good:
if x is None:
    print("A")

– do not use the (in)equality operators when comparing Boolean values to True or False. Again, use is or is not instead:

# Bad:
my_boolean_value = 2 > 1
if my_boolean_value == True:
    print("A")
else:
    print("B")

# Good:
my_boolean_value = 2 > 1
if my_boolean_value is True:
    print("A")
else:
    print("B")

# Better:
my_boolean_value = 2 > 1
if my_boolean_value:
    print("A")
else:
    print("B")

– for readability purposes, use the is not operator instead of not … is:

# Bad:

if not x is None:
    print("It exists")

# Good:
if x is not None:
    print("It exists")

Note: avoid using if x: to express if x is not None: when you want to check if a given variable or argument set to None by default has been assigned a different value.

– when you want to “catch" an exception, refer to specific exceptions rather than use the bare except: clause only:

try:
    import my_module
except ImportError:
    my_module = None

– when checking for prefixes or suffixes, use the ''.startswith() and ''.endswith() string methods, as they’re cleaner and less error prone. Generally, it’s better to use string methods over importing the string module.

# Bad:
if name[:4] == 'Adam':
    # do something

# Good:
if name.startswith('Adam'):
    # do something

For more suggestions about how to write better code and what practices you should avoid, see the official PEP 8 Programming Recommendations page.
Now, let’s put some of the things we’ve learned into practice.

What is PEP 257? PEP 257 is a document created as part of the Python Developer's Guide, which makes an attempt to standardize the high-level structure of docstrings. It outlines the conventions, best practices, and semantics (not laws or regulations!) associated with documenting Python code using docstrings. In short, it tries to answer the following two questions:

What should Python docstrings contain?
How should Python docstrings be used?
What are docstrings? A docstring is "a string literal that occurs as the first statement in a module, function, class, or method definition. Such a docstring becomes the __doc__ special attribute of that object." (PEP 257)

In other words, docstrings are Python documentation strings that are used in the class, module, function, and method definition in order to provide information about the functionality of a larger piece of code in a prescriptive way.

They help programmers (including you) to remember and understand the purpose, operation, and capabilities of particular code blocks or sections.
Docstring vs. comments. Before we move on, we need to understand this essential distinction (as their names suggest): comments are used for commenting your code, while docstrings are used for documenting your code. So, what is the difference between comments and docstrings, and eventually between commenting and documenting code?

Look at the table below, where we want to show you some of the differences between comments and docstrings in Python:

Comments                                              | Docstrings
------------------------------------------------------|--------------------------------------------------------------
Comments are non-executable statements in Python,     | Docstrings can be accessed by reading the source code,
which means that they are ignored by the Python       | and by using the __doc__ attribute or the help() function.
interpreter; they are not stored in memory, and       |
cannot be accessed during program execution           |
(i.e. they can be accessed by looking at the code).   |

The main purpose of comments is increasing the        | The main purpose of docstrings is documenting your code –
readability and understandability of the code, and    | describing its use, functionality, and capabilities to
explaining the code to the user in a meaningful way.  | users who do not necessarily need to know how it works.
The user here means both other programmers and you    |
(e.g. when you go back to your code after some time). |

Comments cannot be turned into documentation; their   | Docstrings can be easily turned into actual documentation,
purpose is to simplify the code, provide precise      | which describes a module's or function's behavior, the
information, and help to understand the intention     | meaning of parameters, or the purpose of a specific package.
of a particular snippet/line.                         |

Of course, as you'll see in the next pages, there's much more that we want to tell you about docstrings: how to use them, why use them, and where; and – as you expect – the difference between comments and docstrings will become even more evident.

Why comment? Why document? Before we delve into the topic of docstrings, let's try to answer the question: why is commenting and documenting code important?

Essentially, we must not forget this simple rule by Guido van Rossum: "Code is more often read than written", which basically means that the code we write today will most likely be read in the future – either by you, or by another programmer, or even teams of programmers. 
It is therefore crucial that we develop such programming and code writing habits that will allow the developers and other users to understand the code's whys and hows, as this will make the reusing of and contributing to code much easier. So, we should agree that documenting code helps to maintain a cleaner, more readable, and more sustainable code, which means it's one of the best practices a good, responsible developer should adopt as part of their daily programming workshop toolset.

A quick recap of comments. We hope that you remember that comments in Python are created using the hash sign (#). They should be rather brief (no more than 72 characters per line), begin with a capital letter, and end with a full stop. If you need to include a longer comment in your code, you can use a multiple-line comment, in which case you should use the hash sign at the beginning of each line of comment.

Generally, you should insert comments close to the code you're describing in order to make it clear for the reader which part of the code you're referring to. You should be precise – don't include irrelevant or reduntant information; and most of all – try to design and write your code in such a way that it easily and comprehensibly comments itself (e.g. give self-commenting names to variables).

When use comments? Apart from the most obvious cases, such as code and algorithm descriptions, comments may serve a few other useful purposes. For example:
they can help you tag those sections of code that are to be done in the future, or are left for further improvement, e.g.:
# TODO: Add a function that takes the val and prc arguments.

they can help you comment (and uncomment) those sections of code that you want to test, e.g.:

def fun(val):
    return val * 2

user_value = int(input("Enter the value: "))
# fun(user_value)
# user_value = user_value + "foo"

print(fun(user_value))

they can help you plan your work and outline certain sections of code that you will be designing, e.g.:

# Step 1: Ask the user for the value.
# Step 2: Change the value to an int and handle possible exceptions.
# Step 3: Print the value multiplied by 0.7.

A few words on type hints: PEP 484. Before we move on from talking about comments to elaborating on docstrings, there is one more Python feature that we want to briefly tell you about – type hinting. Type hinting is a mechanism introduced with Python 3.5 and desecribed in PEP 484 that allows you to equip your code with additional information without using comments. It's an optional, but more formalized, feature that makes it possible for you to use the Python built-in typing module to provide type hint information in your code in order to leave certain suggestions, mark certain possible problems that may come up in the development process, and label specific names with type information.

In a nutshell, type hinting allows you to statically indicate the type information related to Python objects, which means that you can, for example, add type information to a function – indicate the type of an argument the function accepts, or the type of the value it will return. Look at the following examples:

# No type information added:
def hello(name):
    return "Hello, " + name

# Type information added to a function:
def hello(name: str) -> str:
    return "Hello, " + name

Type hinting is optional, which means PEP 484 does not obligate you to leave any static typing-related information in your code. The first example is free from any type hints. In the second example, the str annotation, which indicates that the name argument passed to the hello() function should be of type str helps us minimize the risk of certain (un)expected situations – it reduces the risk of passing a wrong type of value to the function. The -> str annotation indicates, too, that the hello() function will return a value of type str, which of course is a string.

What does it all mean for you, and how can you take advantage of type hinting in Python?

First of all, type hinting can help you document your code. Instead of leaving argument- and response-related information in docstrings, you can use the language itself to serve this purpose. This may be an elegant and useful way to highlight some of the more important code information, especially when publishing code in a project, sharing it with other developers, or leaving hints for yourself when you have to come back to the source code in the future. In some of the bigger software development projects, type hinting is a recommended practice that helps teams better understand the ways that types run through the code.

Type hinting allows you to notice certain kinds of errors more effectively and write a more beautiful and, most of all, cleaner code. When using type hints, you more carefully think about types in your code, which helps to prevent or detect some of the errors that may result from the dynamic nature of Python. (However, we're not advocates for making Python require static typing.)

You must remember that type hinting in Python is not used at runtime, which means all the type information you leave in the code in the form of annotations is erased when the program is executed. In other words, type hinting does not have any effect on the operation of your code. On the other hand, when used along with some type checking system or lint-like tools that you can plug in to your editor or IDE, it can support your code-writing by autocompleting your typing and spotting and highlighting errors before your code is executed.

Since type hints have no effect on the source code, this means that they have no impact on performance times (characters are ignored by Python at runtime, which has no influence on interpretation/compilation speedups).

In this short section we've only touched on the most fundamental questions related to the subject of type hinting in Python. For more information about the topic, we encourage you to have a closer look at PEP 483 – The theory of type hints, PEP 484 – Type hints (information about the syntax for type annotations, static analysis and refactoring, type checking), and PEP 3107 – Function Annotations (information about the syntax for adding metadata annotations to Python functions).

Now it's time to move on to docstrings.

Docstrings – where and how? We've already said that docstrings can be used in classes, modules, functions, and method definitions. Now we want to elaborate on this: there are cases where they not only can be included, but should be included. To be more precise – all public modules, functions, classes, and methods that are exported by a given module should have docstrings.

Non-public methods do not need to contain docstrings. However, it is recommended that you leave a comment right after the def line describing what the method actually does. In the case of packages, these should be documented too, and you can write package docstrings in the module docstring of the __init__.py file in the package folder.

As we've said before, docstrings are string literals that occur as the first statement in a module, function, class, or method. However, it is important (and fair) to add that string literals can also occur in many other places in Python code, and still serve as documentation. And even though they may no longer be accessible as runtime object attributes, they can still be extracted by some specific software tools (for more information about these, consult PEP 256, which provides information about Docutils, a Python Dosctring Processing System).

# In Python, a string literal is a sequence of characters enclosed in quotes that represents a string value directly in your code. 
# A literal is a fixed value in your code. So a string literal is just a hardcoded piece of text — like "hello" or 'Python rocks'.
# A string literal in Python is just a way to write a string value directly in your code using quotes. It's how you define text values that your program can use.

And now, without going into too many details, it's enough to tell you that we distinguish two kinds of such "extra dosctrings" – these are:

attribute docstrings, which are located immediately after an assignment statement at the top level of a module (module attributes), class (class attributes), or the __init__ method definition of a class (instance attributes). These are interpreted by the extraction tools, such as Docutils, as "the docstrings of the target of the assignment statement." (If you are interested in learning more about attribute docstrings, you are more than welcome to dive into PEP 224 yourself. At this point, we just want you to be aware of these.) additional dosctrings, which are located immediately after another docstring. (The original idea for additional docstrings was taken from PEP 216, which in turn was later superseded by PEP 287 – again, you're more than welcome to take a look at those PEPs.)
How to create docstrings. Docstrings should be surrounded by triple double quotes ("""triple double quotes"""). For example:

def my_function():
    """I am a docstring."""
    ...

If you need to use any backslashes in your docstrings, then you should follow the r"""raw triple double quotes""" format. If you need to use Unicode docstrings, then follow the u"""Unicode triple-quote strings""" format.

One-line vs. multi-line docstrings. There are two forms of docstrings. And even though each of them serves the same purpose (i.e. is supposed to provide documentation), which one you're going to use will depend on certain conditions like how much information it is necessary to provide. These are:
one-line docstrings – they are used for simple and short descriptions, and should fit on one line

multi-line docstrings – they are used for more difficult cases, and should consist of a summary line followed by one blank line and a more elaborate description.

Let's talk a bit more about each of them.

One-line docstrings
One-line docstrings should be used for rather simple, obvious, and short descriptions. They should take up one line only, and be surrounded by triple double quotes (the closing quotes should be on the same line as the opening quotes as this helps to keep the code clean and elegant).

Important notes:

a docstring should begin with an upper-case letter (unless an identifier begins the sentence) and end with a period;
a docstring should prescribe the code segment's effect, not describe it. In other words, it should take the form of an imperative (e.g. "Do this", "Return that", "Compute this", "Convert that", etc.), not a description (e.g. "Does this", "Returns that", "Forms this", "Extends that", etc.). For example:

def greeting(name):
    """Take a name and return its replicated form."""
    return name * 2

a docstring should not just simply repeat the function or method parameters. For example:

# Don't do this:
def my_function(x, y):
    """my_function(x, y) -> list"""
...

# Instead, try to do something like this:
def my_function(x, y):
    """Compute the angles and return a list of coordinates."""
...

Do not use a blank line above or under a one-line docstring unless you're documenting a class, in which case you should put a blank line after all the docstrings that document it:

#bad
def calculate_tax(x, y):

    """I am a one-line docstring."""
    
    return (x+y) * 0.25

#good
def calculate_tax(x, y):
    """I am a one-line docstring."""
    return (x+y) * 0.25


Multi-line docstrings. Multi-line docstrings should be used for non-obvious cases and more detailed descriptions of code segments. They should have a summary line, similar to what a one-line docstring looks like, followed by a blank line and a more elaborate description. The summary line may be located on the same line as the open triple double quotes, or put on the next line. The end quotes should be put on a separate line.

Important notes:

a multi-line docstring should be indented to the same level as the open quotes, for example:

def king_creator(name="Greg", ordinal="I", country="Neverland"):
    """Create a king following the article title naming convention.
    
    Keyword arguments:
    :arg name: the king's name (default: Greg)
    :type name: str
    :arg ordinal: Roman ordinal number (default: I)
    :type ordinal: str
    :arg country: the country ruled (default: Neverland)
    :type country: str
    """
    if name == "Voldemort":
        return "Voldemort is a reserved name."
    ...

you should insert a blank line after all the multi-line docstrings that are documenting a class;

script docstrings (in the sense of stand-alone programs/single file executables) should document the script's function, command line syntax, environment variables, and files. The description should be balanced in a way that it helps new users understand the script's usage, as well as provide a quick reference to all the program's features for the more experienced user;

module docstrings should list the classes, exceptions, and functions exported by the module;

package docstrings (understood as the docstring of the package's __init__.py module) should list the modules and subpackages exported by the package;

docstrings for functions and class methods should summarize their behavior and provide information about the arguments (including optional arguments), values, exceptions, restrictions, etc.

class docstrings should also summarize its behavior as well as document the public methods and instance variables. For example:

class Vehicle:
    """A class to represent a Vehicle.
    
    Attributes:
    -----------
    vehicle_type: str
        The type of the vehicle, e.g. a car.
    id_number: int
        The vehicle identification number.
    is_autonomous: bool
        self-driving -> True, not self-driving -> False
   
    Methods:
    --------
    report_location(lon=45.00, lat=90.00)
        Print the vehicle id number and its current location.
        (default longitude=45.00, default latitude=90.00)
    """
    
    def __init__(self, vehicle_type, id_number, is_autonomous=True):
        """
        Parameters:
        -----------
        vehicle_type: str
            The type of the vehicle, e.g. a car.
        id_number: int
            The vehicle identification number.
        is_autonomous: bool, optional
            self-driving -> True (default), not self-driving -> False
        """
        
        self.vehicle_type = vehicle_type
        self.id_number = id_number
        self.is_autonomous = is_autonomous
    
    def report_location(self, id_number, lon=45.00, lat=90.00):
        """
        Print the vehicle id number and its current location.
        
        Parameters:
        -----------
        id_number: int
            The vehicle identification number.
        lon: float, optional
            The vehicle's current longitude (default is 45.00)
        lat: float, optional
            The vehicle's current latitude (default is 90.00)
        """

    ...
    ...
    ...


Docstring formatting types. You may have noticed that we have used two different docstring formats for documenting the king_creator() function and the Vehicle class. The first type of formatting is called reStructuredText, and it's the official Python documentation standard explained and described in PEP 287. The second example uses the NumPy/SciPy docstrings format (for details, click here, which is a combination of the Google docstrings format and the reStructuredText format.

Both formatting types are good for the purposes of creating formal documentation, and both of them are supported by Sphinx, one of the most popular Python documentation generators.

Sphinx is a great tool for creating documentation for software development projects. It uses reStructuredText as its markup language, and has a lot of useful features, such as supporting the HTML output format, automatic testing of code snippets, extensive cross-references, and a hierarchical structure, which lets you define a document tree. Check it out.

How to document a project. When documenting a Python project, depending on the nature of the project (i.e. private, shared, public, open source/public domain), you should first and foremost define its users and think about their needs. Creating a user persona may come in handy here as it will help you identify the ways the users will use your project.

This means you can easily improve their experience by thinking about how they're going to utilize your code and trying to predict the most common issues they may come across when doing so.

Generally, a project should contain the following documentation elements:

a readme, which provides a brief summary of the project, its purpose, and possibly some installation guidelines;
an examples.py file, which is a script that demonstrates a few examples of how to utilize the project;
a license in the form of a txt file (particularly important for Open Source and Public Domain projects)
a how to contribute file which provides information about the possible ways of contributing to the project (shared, open source, and public domain projects).
Because documenting your code can be a rather exhausting and time-consuming activity, you are definitely encouraged to use some of the tools that could help you auto-generate documentation in the desired format, and deal with documentation updates and versioning in an effective and efficient way.

There are many documentation tools and resources available, such as Sphinx, which we've already mentioned, or the highly popular pdoc, and many more. We encourage you to follow this path.

Linters and fixers. How do you maintain the good quality of your code? Well, you already know that you can follow the style guides such as PEP 8 or PEP 257, and write your code in a readable and consistent way. You can (and possibly should) adopt the Zen of Python philosophy, with all its good advice for writing an elegant and maintainable code, and use the type hinting mechanism. You can observe how others write code and document it as part of their projects (Look at the Python Standard Library or the Requests library), and learn from them. Finally, you can use linters.

Right. But what is a linter? Well, it's a tool that helps you write your code, because it analyzes it for any stylistic anomalies and programming errors against a set of pre-defined rules. In other words, it's a program that analyzes your code and reports such issues as structural and syntax errors, consistency breakups, and a lack of compatibility with best practices or code style guidelines such as PEP 8. The most popular linters are: Flake8, Pylint, Pyflakes, Pychecker, Mypy, and Pycodestyle (formerly Pep8) – the official linter tool to check Python code against PEP 8 conventions.

A fixer, on the other hand, is a program that helps you fix these issues and format your code to be consistent with the adopted standards. The most popular fixers are: Black, YAPF, and autopep8.

Most editors and IDEs (e.g. PyCharm, Spyder, Atom, Sublime Text, Visual Studio, Eclipse + PyDev, VIM, or Thonny) support linters, which means you can run them in the background as you write code. This makes it possible to detect, highlight, and identify many problem areas in your code, such as typos, wrong tabbing and indentation issues, function calls with the wrong number of arguments, stylistic inconsistencies, dangerous code patterns, and many more, and automatically format your code to a pre-defined specification.

That being said, we encourage you to explore the territory of linters and fixers yourself, and start using them to maintain high-quality Python code, and simply make your life easier.

How to access docstrings. We've nearly made it to the end of our journey with PEP 257 and docstrings. The last question that still remains to be fully answered is: how can we actually access docstrings?

We do it by using the Python __doc__ attribute – if any string literals are present after the definition of a function/module/class/method, then they are associated with the object as its __doc__ attribute, and this attribute provides the documentation of that object.

Run the code in the editor to see what happens.

def my_fun(a, b):
    """The summary line goes here.

    A more elaborate description of the function.

    Parameters:
    a: int (description)
    b: int (description)

    Returns:
    int: Description of the return value.
    """
    return a*b

print(my_fun.__doc__)

Your output should be like this:

The summary line goes here.
	
	A more elaborate description of the function.
	
	Parameters:
	a: int (description)
	b: int (description)
	
	Returns:
	int: Description of the return value.
output


But there's also another way to access the documentation strings – you can use the help() function. Make a small amendment in your code: replace the print function invocation with the following line:

help(my_fun)

Run the code and see what happens. What are your conclusions? As you can see, the output is lengthier and more descriptive:

Help on function my_fun in module __main__:

my_fun(a, b)
    The summary line goes here.
    
    A more elaborate description of the function.
    
    Parameters:
    a: int (description)
    b: int (description)
    
    Returns:
    int: Description of the return value.
output

Now try to access the docstrings of any of the Python built-in functions (e.g. print()). Then import a module and access the module documentation. Experiment with the __doc__ method and the help() function. See what outputs you get and how they differ from each other. Use them to learn more information about the Python built-in objects.

You've learned a lot. You can be proud of yourself! Congratulations! You've reached the end of the course.





